<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-TW" lang="zh-TW">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.70.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Golang Memory Management (based on 1.12.5) &middot; No Idiots Allowed Here</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://chihkaiyu.github.iocss/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://chihkaiyu.github.iocss/poole.css">
  <link type="text/css" rel="stylesheet" href="https://chihkaiyu.github.iocss/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://chihkaiyu.github.iocss/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://chihkaiyu.github.io/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://chihkaiyu.github.io/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://chihkaiyu.github.io"><h1>No Idiots Allowed Here</h1></a>
      <p class="lead">
       Are you an idiot? 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://chihkaiyu.github.io">Home</a> </li>
        <li><a href="https://chihkaiyu.github.io/page/about"> About </a></li><li><a href="https://chihkaiyu.github.io/post"> Archives </a></li><li><a href="https://chihkaiyu.github.io/page/tags"> Tags </a></li>
      </ul>
    </nav>

    <p>&copy; 2020. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Golang Memory Management (based on 1.12.5)</h1>
  <time datetime=2019-07-02T00:03:00&#43;0800 class="post-date">Tue, Jul 2, 2019</time>
  <h1 id="golang-memory-management-based-on-1125">Golang Memory Management (based on 1.12.5)</h1>
<p>此文是我在看過許多 Golang 記憶體管理的文章後，再搭配 souce code 所整理出來的。有點像是利用 souce code 來驗證我是否理解網路上所搜尋到的文章。<br>
Golang 基於 <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc (Thread-Caching Malloc)</a> 加以修改，改為適合自己的 allocator。<br>
TCMalloc 有幾項特點：</p>
<ul>
<li>盡可能先分配一大塊記憶體，以降低分配及釋放的 overhead</li>
<li>將這塊記憶體切成各種大小的 span，以降低 memory fragmentation</li>
<li>分配特別小的物件時優化，以提升記憶體使用率</li>
<li>Thread 裡有 cache，使用時可以不必 lock 以提升效率</li>
</ul>
<h1 id="terminology">Terminology</h1>
<p>Golang memory management 裡有許多角色，此段落先簡單介紹各角色功用，下段落會詳細各角色的結構及彼此之間的關係。<br>
下圖為大致架構圖，可一邊閱讀一邊參閱：</p>
<p><img src="https://chihkaiyu.github.io/content/images/2019/07/golang_memory_architecture.png" alt=""></p>
<h2 id="mspan">mspan</h2>
<p><code>mspan</code> 是 Golang 記憶體管理最小單位，由數頁 page 所組成，每一個 <code>mspan</code> 都會對應到一個 span class，用來決定該如何切割該 <code>mspan</code> 裡的 page。其 <code>mspan</code> 是 double-linked list。<br>
page 經過切割後變為 object，此 object 才是真正分配記憶體的最小單位。</p>
<h2 id="mcache">mcache</h2>
<p>每個 P (Golang scheduler 的 logic processor)，會綁定一個 <code>mcache</code>，由於同一時間只會有一個 G (goroutine) 在 P 上跑，所以在存取時並不需要 lock。<br>
當 <code>mcache</code> 上的 <code>mspan</code> 已經沒有空間了，便會向 <code>mcentral</code> 申請一個有空間的 <code>mspan</code> 來替換舊的 <code>mspan</code>。</p>
<h2 id="mcentral">mcentral</h2>
<p><code>mcentral</code> 用來管理 <code>mspan</code>，一個 <code>mcentral</code> 負責一種 span class 的 <code>mspan</code>。<br>
當 <code>mcentral</code> 無 <code>mspan</code> 可用時，便會向 <code>mheap</code> 申請新的 <code>mspan</code> 加入。
目前總共有 64 種 sizes，又根據是否存放 pointer 分為 scan 及 noscan 兩種。所以 <code>mheap</code> 裡總共有 134 (67*2) 個 <code>mcentral</code>。<br>
這是為了加速 GC 的 mark 階段，在 non-scan 裡，一定不會有 pointer，所以不需一個一個往下檢查。</p>
<h2 id="mheap">mheap</h2>
<p><code>mheap</code> 在整個 Golang runtime 裡只會存在一個，Golang 所用到的所有記憶體都要來向 <code>mheap</code> 申請。<br>
而 <code>mheap</code> 自身擁有的記憶體不夠時，會再向 OS 申請，每次申請至少 1MB 的記憶體，減少向 OS 申請的 overhead。<br>
<code>mheap</code> 在管理記憶體時是以 page 為單位在管理的，這裡的 page 並不是 OS 層級的 page。Golang 的一頁 page 大小為 8k bytes。</p>
<h2 id="arena">arena</h2>
<p>Golang 的 heap 是由一堆 <code>arena</code> 對齊記憶體位址所組成的。一個 <code>arena</code> 大小為 64MB (不同平台、架構有所不同，此文皆以 Linux-64bit 為主)。</p>
<h2 id="heaparena">heapArena</h2>
<p>每一個 <code>arena</code> 都會有一相對應的 <code>heapArena</code>，這裡存放了一些 <code>arena</code> 的 metadata，像是 <code>bitmap</code> 或是 <code>spans</code>。<br>
在 <code>mheap</code> 裡的 <code>heapArena</code> 是一個二維 array，在大多數架構下，第一層通常只有一個 element。</p>
<h2 id="span-class">span class</h2>
<p>目前共有 67 種 size classes，每種 class 訂出了其 span 多大、其 object 多大。<br>
而每一種 size 又會分為 scan 及 noscan 兩種，所以共有 134 種 span class。<br>
每個 <code>mcentral</code> 負責一種 span class，其包含的所有 <code>mspan</code> 將會按照其規格劃分。</p>
<h1 id="component">Component</h1>
<h2 id="virtual-memory-layout">Virtual Memory Layout</h2>
<p>Golang 的 virtual memory layout 長相如下：</p>
<p><img src="https://chihkaiyu.github.io/content/images/2019/07/golang_memory_layout.png" alt=""></p>
<p>Golang 的 heap 是由一堆 arena 所組成，每個 arena 會對齊。而每一個 arena 會有一個相對應的 <code>heapArena</code> (<code>mheap.arenas</code>)，裡面存放 <code>spans</code> 及 <code>bitmap</code>，是 arena 的 metadata。<br>
arena 根據不同 CPU 架構、OS 會有所不同，常見的 linux 64-bit 目前是 64MB。<br>
在增加 arena 時，會盡量試著讓 arena 是連續的，如此在分配較大的 <code>mspan</code> 時便能橫跨 arena。</p>
<h2 id="mspan-1">mspan</h2>
<p><a href="https://github.com/golang/go/blob/go1.12.5/src/runtime/mheap.go#L316">Source code</a></p>
<p>下列是 <code>mspan</code> 結構，僅列出此文會講到的幾個 fields：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mheap.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mspan</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>     <span style="color:#75715e">// 指向下一個 mspan
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">prev</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>     <span style="color:#75715e">// 指向前一個 mspan
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">list</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mSpanList</span> <span style="color:#75715e">// For debugging. TODO: Remove.
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">startAddr</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 此 span 第一個 byte 的位置，即 s.base()
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">npages</span>    <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 此 span 所擁有的 page 數量
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// freeindex 值為 0 - nelem 之間，用來標示下一個「可能」可用的 object 位址。
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 在 freeindex 之前的 object 皆已被使用，而之後的 object 可能被使用，也可能還沒。
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 搭配 allocCache 使用可以快速找出可使用的 object，而不需全部檢查一次
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">freeindex</span> <span style="color:#66d9ef">uintptr</span>
	<span style="color:#a6e22e">nelems</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 此 span 所擁有的 object 數量
</span><span style="color:#75715e"></span>    
    <span style="color:#75715e">// 從 freeindex 位置開始 cache allocBits，存 allocBits 的補數，
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 因此可以直接使用 ctz (count trailing zero) 快速找出可用的 object。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">allocCache</span> <span style="color:#66d9ef">uint64</span>

    <span style="color:#a6e22e">allocBits</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">gcBits</span> <span style="color:#75715e">// 標示哪些 object 被分配了，哪些還沒
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gcmarkBits</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gcBits</span> <span style="color:#75715e">// 標示哪些 object 被標記了，哪些還沒
</span><span style="color:#75715e"></span>	
	<span style="color:#75715e">// sweep generation:
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// if sweepgen == h-&gt;sweepgen - 2，此 mspan 需要 sweep
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// if sweepgen == h-&gt;sweepgen - 1，此 mspan 正在被 swept
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// if sweepgen == h-&gt;sweepgen，此 mspan 已經被 swept 了，且準備好被使用了
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// if sweepgen == h-&gt;sweepgen + 1，此 mspan 在 sweep 開始前被 cached 了，現在還是被 cached 且需要 sweep
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// if sweepgen == h-&gt;sweepgen + 3，此 mspan 被 swept 後被 cached 了，現在還是被 cached
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// h-&gt;sweepgen 經過每次 GC 後就增加 2
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sweepgen</span>    <span style="color:#66d9ef">uint32</span>
	<span style="color:#a6e22e">allocCount</span>  <span style="color:#66d9ef">uint16</span>     <span style="color:#75715e">// 此 span 已被分配的 object 數量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spanclass</span>   <span style="color:#a6e22e">spanClass</span>  <span style="color:#75715e">// 此 span 的 class
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">state</span>       <span style="color:#a6e22e">mSpanState</span> <span style="color:#75715e">// mspaninuse etc
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">needzero</span>    <span style="color:#66d9ef">uint8</span>      <span style="color:#75715e">// 分配前是否需要 zeroed
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">elemsize</span>    <span style="color:#66d9ef">uintptr</span>    <span style="color:#75715e">// 此 span 一個 object 的大小 computed from sizeclass or from npages
</span><span style="color:#75715e"></span>}</code></pre></div></p>
<h2 id="size-class">size class</h2>
<p><a href="https://github.com/golang/go/blob/go1.12.5/src/runtime/sizeclasses.go#L6">Source code</a></p>
<p>下表為 Golang 所有的 size class，下列解釋各 column 意義：</p>
<ul>
<li>class：此 class 的編號，分類時皆使用此編號作為 index</li>
<li>bytes/obj：此 class 一個 object 的大小</li>
<li>bytes/span：此 class 一個 mspan 的大小</li>
<li>objects：此 class 的 object 數量</li>
<li>tail waste：此 class 因無法完整分配所造成的浪費，例如 class 4，浪費了 32 bytes = 8192 - 48*170</li>
<li>max waste：此 class 最多可能浪費的空間，計算公式為：((object size - (前一級的 object size + 1)) * object 數量 + tail waste) / mspan size，例如 class 4 為 31.52% = ((48 - (32 + 1)) * 170 + 32) / 8192</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// sizeclasses.go
</span><span style="color:#75715e">// class  bytes/obj  bytes/span  objects  tail waste  max waste
</span><span style="color:#75715e">//     1          8        8192     1024           0     87.50%
</span><span style="color:#75715e">//     2         16        8192      512           0     43.75%
</span><span style="color:#75715e">//     3         32        8192      256           0     46.88%
</span><span style="color:#75715e">//     4         48        8192      170          32     31.52%
</span><span style="color:#75715e">//     5         64        8192      128           0     23.44%
</span><span style="color:#75715e">//     6         80        8192      102          32     19.07%
</span><span style="color:#75715e">//     7         96        8192       85          32     15.95%
</span><span style="color:#75715e">//     8        112        8192       73          16     13.56%
</span><span style="color:#75715e">//     9        128        8192       64           0     11.72%
</span><span style="color:#75715e">//    10        144        8192       56         128     11.82%
</span><span style="color:#75715e">//    11        160        8192       51          32      9.73%
</span><span style="color:#75715e">//    12        176        8192       46          96      9.59%
</span><span style="color:#75715e">//    13        192        8192       42         128      9.25%
</span><span style="color:#75715e">//    14        208        8192       39          80      8.12%
</span><span style="color:#75715e">//    15        224        8192       36         128      8.15%
</span><span style="color:#75715e">//    16        240        8192       34          32      6.62%
</span><span style="color:#75715e">//    17        256        8192       32           0      5.86%
</span><span style="color:#75715e">//    18        288        8192       28         128     12.16%
</span><span style="color:#75715e">//    19        320        8192       25         192     11.80%
</span><span style="color:#75715e">//    20        352        8192       23          96      9.88%
</span><span style="color:#75715e">//    21        384        8192       21         128      9.51%
</span><span style="color:#75715e">//    22        416        8192       19         288     10.71%
</span><span style="color:#75715e">//    23        448        8192       18         128      8.37%
</span><span style="color:#75715e">//    24        480        8192       17          32      6.82%
</span><span style="color:#75715e">//    25        512        8192       16           0      6.05%
</span><span style="color:#75715e">//    26        576        8192       14         128     12.33%
</span><span style="color:#75715e">//    27        640        8192       12         512     15.48%
</span><span style="color:#75715e">//    28        704        8192       11         448     13.93%
</span><span style="color:#75715e">//    29        768        8192       10         512     13.94%
</span><span style="color:#75715e">//    30        896        8192        9         128     15.52%
</span><span style="color:#75715e">//    31       1024        8192        8           0     12.40%
</span><span style="color:#75715e">//    32       1152        8192        7         128     12.41%
</span><span style="color:#75715e">//    33       1280        8192        6         512     15.55%
</span><span style="color:#75715e">//    34       1408       16384       11         896     14.00%
</span><span style="color:#75715e">//    35       1536        8192        5         512     14.00%
</span><span style="color:#75715e">//    36       1792       16384        9         256     15.57%
</span><span style="color:#75715e">//    37       2048        8192        4           0     12.45%
</span><span style="color:#75715e">//    38       2304       16384        7         256     12.46%
</span><span style="color:#75715e">//    39       2688        8192        3         128     15.59%
</span><span style="color:#75715e">//    40       3072       24576        8           0     12.47%
</span><span style="color:#75715e">//    41       3200       16384        5         384      6.22%
</span><span style="color:#75715e">//    42       3456       24576        7         384      8.83%
</span><span style="color:#75715e">//    43       4096        8192        2           0     15.60%
</span><span style="color:#75715e">//    44       4864       24576        5         256     16.65%
</span><span style="color:#75715e">//    45       5376       16384        3         256     10.92%
</span><span style="color:#75715e">//    46       6144       24576        4           0     12.48%
</span><span style="color:#75715e">//    47       6528       32768        5         128      6.23%
</span><span style="color:#75715e">//    48       6784       40960        6         256      4.36%
</span><span style="color:#75715e">//    49       6912       49152        7         768      3.37%
</span><span style="color:#75715e">//    50       8192        8192        1           0     15.61%
</span><span style="color:#75715e">//    51       9472       57344        6         512     14.28%
</span><span style="color:#75715e">//    52       9728       49152        5         512      3.64%
</span><span style="color:#75715e">//    53      10240       40960        4           0      4.99%
</span><span style="color:#75715e">//    54      10880       32768        3         128      6.24%
</span><span style="color:#75715e">//    55      12288       24576        2           0     11.45%
</span><span style="color:#75715e">//    56      13568       40960        3         256      9.99%
</span><span style="color:#75715e">//    57      14336       57344        4           0      5.35%
</span><span style="color:#75715e">//    58      16384       16384        1           0     12.49%
</span><span style="color:#75715e">//    59      18432       73728        4           0     11.11%
</span><span style="color:#75715e">//    60      19072       57344        3         128      3.57%
</span><span style="color:#75715e">//    61      20480       40960        2           0      6.87%
</span><span style="color:#75715e">//    62      21760       65536        3         256      6.25%
</span><span style="color:#75715e">//    63      24576       24576        1           0     11.45%
</span><span style="color:#75715e">//    64      27264       81920        3         128     10.00%
</span><span style="color:#75715e">//    65      28672       57344        2           0      4.91%
</span><span style="color:#75715e"></span><span style="color:#f92672">//</span>    <span style="color:#ae81ff">66</span>      <span style="color:#ae81ff">32768</span>       <span style="color:#ae81ff">32768</span>        <span style="color:#ae81ff">1</span>           <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">12.50</span><span style="color:#f92672">%</span></code></pre></div>
<h2 id="mcache-1">mcache</h2>
<p><a href="https://github.com/golang/go/blob/go1.12.5/src/runtime/mcache.go#L19">Source code</a></p>
<p>下列是 <code>mcache</code> 結構，僅列出此文會講到的幾個 fields：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mcache.go
</span><span style="color:#75715e">//go:notinheap
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mcache</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">tiny</span>             <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// tiny object 的起始位址
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tinyoffset</span>       <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 從 tiny 開始的 offset，即下次分配 tiny 的地方
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">local_tinyallocs</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// tiny object 的數量
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">alloc</span> [<span style="color:#a6e22e">numSpanClasses</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> <span style="color:#75715e">// 各式大小的 mspan list，共有 134 種，其 index 是 spanClass
</span><span style="color:#75715e"></span>}</code></pre></div></p>
<h2 id="mcentral-1">mcentral</h2>
<p><a href="https://github.com/golang/go/blob/go1.12.5/src/runtime/mcentral.go#L20">Source code</a></p>
<p>下列是 <code>mcentral</code> 結構，僅列出此文會講到的幾個 fields：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mcentral.go
</span><span style="color:#75715e">//go:notinheap
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mcentral</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">lock</span>      <span style="color:#a6e22e">mutex</span> <span style="color:#75715e">// 可能同時會有多個 mcache 向 mcentral 要求 mspan，所以需要 lcok
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spanclass</span> <span style="color:#a6e22e">spanClass</span> <span style="color:#75715e">// 表示此 mcentral 是負責哪個 span class
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nonempty</span>  <span style="color:#a6e22e">mSpanList</span> <span style="color:#75715e">// 仍有可用 object 的 mspan double linked list
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">empty</span>     <span style="color:#a6e22e">mSpanList</span> <span style="color:#75715e">// 無可用 object 的 mspan double linked list 或是被 cached 在 mcache 了
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nmalloc</span> <span style="color:#66d9ef">uint64</span> <span style="color:#75715e">// 此 mcentral 所分配的 object 數量
</span><span style="color:#75715e"></span>}</code></pre></div></p>
<h2 id="mheap-1">mheap</h2>
<p><a href="https://github.com/golang/go/blob/go1.12.5/src/runtime/mheap.go#L31">Source code</a></p>
<p>下列是 <code>mheap</code> 結構，僅列出此文會講到的幾個 fields：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mheap.go
</span><span style="color:#75715e">//go:notinheap
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mheap</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">lock</span>      <span style="color:#a6e22e">mutex</span> <span style="color:#75715e">// 可能同時有多個 mcentral 向 mheap 請求，所以需要 lock
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// 下列為 mheap 的兩棵樹堆，以 mspan 的 page 數量排序
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">free</span>      <span style="color:#a6e22e">mTreap</span> <span style="color:#75715e">// 可用且並非回收的 mspan
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">scav</span>      <span style="color:#a6e22e">mTreap</span> <span style="color:#75715e">// 可用且已經回收的 mspan
</span><span style="color:#75715e"></span>	
	<span style="color:#a6e22e">allspans</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> <span style="color:#75715e">// 所有產生的 mspan
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">reclaimIndex</span> <span style="color:#66d9ef">uint64</span> <span style="color:#75715e">// 下一個要被 reclaim 的 page 位址
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">reclaimCredit</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 額外多 reclaim 的 pages，先存在這裡，下次從這裡先扣除
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">scavengeCredit</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 額外多 scavenge 的 pages，先存在這裡，下次從這裡先扣除
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// Malloc stats.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">largealloc</span>  <span style="color:#66d9ef">uint64</span>                  <span style="color:#75715e">// 已分配的 large object bytes 數
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nlargealloc</span> <span style="color:#66d9ef">uint64</span>                  <span style="color:#75715e">// 已分配的 large object 數量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">largefree</span>   <span style="color:#66d9ef">uint64</span>                  <span style="color:#75715e">// 已歸還的 large object bytes 數
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nlargefree</span>  <span style="color:#66d9ef">uint64</span>                  <span style="color:#75715e">// 已歸還的 large object 數量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nsmallfree</span>  [<span style="color:#a6e22e">_NumSizeClasses</span>]<span style="color:#66d9ef">uint64</span> <span style="color:#75715e">// 已歸還的 small object 數量
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// arenas 存放指向 heapArena 的 pointer。
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// arenas 是兩層的 array，目前大多數情況都第一層都只有一個 element，在存取上會較有效率
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// heapArena 儲存各 arena 的 metadata。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">arenas</span> [<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">arenaL1Bits</span>]<span style="color:#f92672">*</span>[<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">arenaL2Bits</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">heapArena</span>

	<span style="color:#a6e22e">arenaHints</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">arenaHint</span> <span style="color:#75715e">// 當 mheap 要增加 heap arenas 時，會從 arenaHints 開始增加
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">allArenas</span> []<span style="color:#a6e22e">arenaIdx</span> <span style="color:#75715e">// allArenas 存放所有 arena 的 index
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// central 存放各種規格的 mcentral，共有 134 種
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">central</span> [<span style="color:#a6e22e">numSpanClasses</span>]<span style="color:#66d9ef">struct</span> {
		<span style="color:#a6e22e">mcentral</span> <span style="color:#a6e22e">mcentral</span>
		<span style="color:#a6e22e">pad</span>      [<span style="color:#a6e22e">cpu</span>.<span style="color:#a6e22e">CacheLinePadSize</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">mcentral</span>{})<span style="color:#f92672">%</span><span style="color:#a6e22e">cpu</span>.<span style="color:#a6e22e">CacheLinePadSize</span>]<span style="color:#66d9ef">byte</span>
	}

	<span style="color:#75715e">// 下列為各結構的 allocator，fixalloc 用來分配 heap 以外且大小固定的 object
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spanalloc</span>             <span style="color:#a6e22e">fixalloc</span> <span style="color:#75715e">// allocator for span*
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cachealloc</span>            <span style="color:#a6e22e">fixalloc</span> <span style="color:#75715e">// allocator for mcache*
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">treapalloc</span>            <span style="color:#a6e22e">fixalloc</span> <span style="color:#75715e">// allocator for treapNodes*
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">arenaHintAlloc</span>        <span style="color:#a6e22e">fixalloc</span> <span style="color:#75715e">// allocator for arenaHints
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//go:notinheap
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">heapArena</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// bitmap 用來表示 arena 哪些位址存放 object，哪些位址是 pointer。
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 一個 byte 的 bitmap 用來表示 4 個在 arena 的 pointer，即兩個 bits 表示一個 pointer。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bitmap</span> [<span style="color:#a6e22e">heapArenaBitmapBytes</span>]<span style="color:#66d9ef">byte</span>

	<span style="color:#75715e">// spans 將 arena 裡的 page 對應到相對應的 mspan。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spans</span> [<span style="color:#a6e22e">pagesPerArena</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>
}</code></pre></div></p>
<h1 id="allocating-flow">Allocating Flow</h1>
<p>Golang 將記憶體分層存取，也依 size 分級存取。對於特別大及特別小的亦有另外的處理方式。<br>
依據 size 及是否為 pointer 分為三種 allocating 流程：</p>
<ul>
<li>Tiny size：<code>&lt; 16 bytes</code> 且不為 pointer 的 object</li>
<li>Small size：<code>&lt;= 32KB</code> 的 object</li>
<li>Large size：<code>&gt; 32KB</code> 的 object</li>
</ul>
<h2 id="tiny-size">Tiny Size</h2>
<p><a href="https://github.com/golang/go/blob/go1.12.5/src/runtime/malloc.go#L864">Source code</a></p>
<p>Tiny size 分配流程大致如下：</p>
<ol>
<li>將分配大小對齊在 2、4、8 上</li>
<li>若該 <code>mcache</code> 有 tiny block 且有合適的空間，便直接分配</li>
<li>若沒有或是空間不合適，則在該 <code>mcache</code> 裡尋找其他 <code>mspan</code></li>
<li>若沒有的話，則向 <code>mcentral</code> 申請新的 <code>mspan</code></li>
<li>若 <code>mcentral</code> 也沒有，則會再向 <code>mheap</code> 申請</li>
<li>視情況調整 <code>mcache</code> 的 tiny block 及 tinyoffset</li>
</ol>
<p>上述行為到第 3 步為止都不需 lock，第 4、5 步都需要 lock，分別 lock 住 <code>mcentral</code> 及 <code>mheap</code>。</p>
<p>下列是 tiny size allocating 的 部份內容：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// malloc.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">typ</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
	<span style="color:#75715e">// 處理 GC 相關事情
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">maxSmallSize</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">noscan</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">size</span> &lt; <span style="color:#a6e22e">maxTinySize</span> {
			<span style="color:#a6e22e">off</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">tinyoffset</span>
			<span style="color:#75715e">// 根據要分配的 size 對齊 offset
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">&amp;</span><span style="color:#ae81ff">7</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#a6e22e">off</span> = <span style="color:#a6e22e">round</span>(<span style="color:#a6e22e">off</span>, <span style="color:#ae81ff">8</span>)
			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">&amp;</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#a6e22e">off</span> = <span style="color:#a6e22e">round</span>(<span style="color:#a6e22e">off</span>, <span style="color:#ae81ff">4</span>)
			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#a6e22e">off</span> = <span style="color:#a6e22e">round</span>(<span style="color:#a6e22e">off</span>, <span style="color:#ae81ff">2</span>)
			}

			<span style="color:#75715e">// 檢查此 mcache 是否有 tiny block
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// 若有且放的下的話，便放進此 tiny block 並調整 offset 後直接返回 pointer
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">off</span><span style="color:#f92672">+</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">maxTinySize</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">tiny</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">tiny</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">off</span>)
				<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">tinyoffset</span> = <span style="color:#a6e22e">off</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">size</span>
				<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">local_tinyallocs</span><span style="color:#f92672">++</span>
				<span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">mallocing</span> = <span style="color:#ae81ff">0</span>
				<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
			}

			<span style="color:#a6e22e">span</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">alloc</span>[<span style="color:#a6e22e">tinySpanClass</span>] <span style="color:#75715e">// 目前沒有 tiny block 或是不夠用，便從 mcache 拿出 mspan
</span><span style="color:#75715e"></span>
			<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nextFreeFast</span>(<span style="color:#a6e22e">span</span>) <span style="color:#75715e">// 利用 mspan.allocCache 快裡找出可用的 object
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">shouldhelpgc</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">nextFree</span>(<span style="color:#a6e22e">tinySpanClass</span>) <span style="color:#75715e">// 找不到的話，便試著從整個 mspan 找出可用的 object
</span><span style="color:#75715e"></span>			}
			<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">v</span>)
			(<span style="color:#f92672">*</span>[<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">uint64</span>)(<span style="color:#a6e22e">x</span>)[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">0</span>
			(<span style="color:#f92672">*</span>[<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">uint64</span>)(<span style="color:#a6e22e">x</span>)[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">0</span>
			
			<span style="color:#75715e">// 根據剩餘的空間決定需不需要替換現在的 tiny block
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> &lt; <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">tinyoffset</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">tiny</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">tiny</span> = uintptr(<span style="color:#a6e22e">x</span>)
				<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">tinyoffset</span> = <span style="color:#a6e22e">size</span>
			}
			<span style="color:#a6e22e">size</span> = <span style="color:#a6e22e">maxTinySize</span>
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// small size 分配流程
</span><span style="color:#75715e"></span>		}
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#75715e">// large size 分配流程
</span><span style="color:#75715e"></span>	}

	<span style="color:#75715e">// 後續處理
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
}</code></pre></div></p>
<p><code>nextFreeFast</code> 利用 <code>allocCache</code> 這個 function 快速找出可用的 object 位置：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// malloc.go
</span><span style="color:#75715e">// nextFreeFast returns the next free object if one is quickly available.
</span><span style="color:#75715e">// Otherwise it returns 0.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">nextFreeFast</span>(<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>) <span style="color:#a6e22e">gclinkptr</span> {
	<span style="color:#a6e22e">theBit</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">Ctz64</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCache</span>) <span style="color:#75715e">// 從低位開始計算 allocCache 有幾個 0
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">theBit</span> &lt; <span style="color:#ae81ff">64</span> {
		<span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">theBit</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">result</span> &lt; <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> { <span style="color:#75715e">// 若找出來的 bit 還在該 mspan 可用的範圍內，便可直接使用
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">freeidx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">freeidx</span><span style="color:#f92672">%</span><span style="color:#ae81ff">64</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">freeidx</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
			}
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCache</span> <span style="color:#f92672">&gt;&gt;=</span> uint(<span style="color:#a6e22e">theBit</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 調整 allocCache，因為此次會用掉一個 object，所以 +1
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> = <span style="color:#a6e22e">freeidx</span> <span style="color:#75715e">// 調整 freeindex
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span><span style="color:#f92672">++</span>
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gclinkptr</span>(<span style="color:#a6e22e">result</span><span style="color:#f92672">*</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">elemsize</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>())
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">// 若無法找到可用的 object，便回傳 0 讓外面處理
</span><span style="color:#75715e"></span>}</code></pre></div></p>
<p>若 <code>nextFreeFast</code> 找不到，便呼叫 <code>nextFree</code>：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// malloc.go
</span><span style="color:#75715e">// nextFree returns the next free object from the cached span if one is available.
</span><span style="color:#75715e">// Otherwise it refills the cache with a span with an available object and
</span><span style="color:#75715e">// returns that object along with a flag indicating that this was a heavy
</span><span style="color:#75715e">// weight allocation. If it is a heavy weight allocation the caller must
</span><span style="color:#75715e">// determine whether a new GC cycle needs to be started or if the GC is active
</span><span style="color:#75715e">// whether this goroutine needs to assist the GC.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Must run in a non-preemptible context since otherwise the owner of
</span><span style="color:#75715e">// c could change.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mcache</span>) <span style="color:#a6e22e">nextFree</span>(<span style="color:#a6e22e">spc</span> <span style="color:#a6e22e">spanClass</span>) (<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">gclinkptr</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>, <span style="color:#a6e22e">shouldhelpgc</span> <span style="color:#66d9ef">bool</span>) {
	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">alloc</span>[<span style="color:#a6e22e">spc</span>]
	<span style="color:#a6e22e">shouldhelpgc</span> = <span style="color:#66d9ef">false</span>
	<span style="color:#a6e22e">freeIndex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nextFreeIndex</span>() <span style="color:#75715e">// 找出下個可用的 freeIndex
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">freeIndex</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> { <span style="color:#75715e">// 若 nextFreeIndex 回傳 nelems 代表該 mspan 已無可用的 object
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> uintptr(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
			println(<span style="color:#e6db74">&#34;runtime: s.allocCount=&#34;</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>, <span style="color:#e6db74">&#34;s.nelems=&#34;</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span>)
			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&#34;</span>)
        }

		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">refill</span>(<span style="color:#a6e22e">spc</span>) <span style="color:#75715e">// 這個 mspan 已經沒有可用的 object 了，呼叫 refill 向 mcentral 申請一個新的 mspan 來替換舊的
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">shouldhelpgc</span> = <span style="color:#66d9ef">true</span>
		<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">alloc</span>[<span style="color:#a6e22e">spc</span>]

		<span style="color:#a6e22e">freeIndex</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nextFreeIndex</span>() <span style="color:#75715e">// 從新的 mspan 找出下一個可用的 freeIndex
</span><span style="color:#75715e"></span>	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">freeIndex</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;freeIndex is not valid&#34;</span>)
	}

	<span style="color:#a6e22e">v</span> = <span style="color:#a6e22e">gclinkptr</span>(<span style="color:#a6e22e">freeIndex</span><span style="color:#f92672">*</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">elemsize</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>()) <span style="color:#75715e">// 順利找到可用的 object，計算 object 的位址後回傳
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span><span style="color:#f92672">++</span>
	<span style="color:#66d9ef">if</span> uintptr(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>) &gt; <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
		println(<span style="color:#e6db74">&#34;s.allocCount=&#34;</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>, <span style="color:#e6db74">&#34;s.nelems=&#34;</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span>)
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;s.allocCount &gt; s.nelems&#34;</span>)
	}
	<span style="color:#66d9ef">return</span>
}</code></pre></div></p>
<p>接著來看看 <code>nextFreeIndex</code> 如何找出可用的 <code>freeIndex</code>：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mbitmap.go
</span><span style="color:#75715e">// nextFreeIndex returns the index of the next free object in s at
</span><span style="color:#75715e">// or after s.freeindex.
</span><span style="color:#75715e">// There are hardware instructions that can be used to make this
</span><span style="color:#75715e">// faster if profiling warrants it.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>) <span style="color:#a6e22e">nextFreeIndex</span>() <span style="color:#66d9ef">uintptr</span> {
	<span style="color:#a6e22e">sfreeindex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span>
	<span style="color:#a6e22e">snelems</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span>

	<span style="color:#75715e">// 若目前的 freeIndex 為該 mspan 總可用 object 數量時，代表此 mspan 已無可用的 object 了
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sfreeindex</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">snelems</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sfreeindex</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sfreeindex</span> &gt; <span style="color:#a6e22e">snelems</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;s.freeindex &gt; s.nelems&#34;</span>)
	}

	<span style="color:#a6e22e">aCache</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCache</span>

	<span style="color:#75715e">// 下面 loop 利用 allocCache 與 freeIndex 來 iterate 整個 mspan 試著找出可用的 object 位置
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bitIndex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">Ctz64</span>(<span style="color:#a6e22e">aCache</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">bitIndex</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">64</span> { <span style="color:#75715e">// sys.Ctz64 回傳 64 的話，代表 allocCache 裡全部都是 0，代表 allocCache 所涵蓋的部份沒有可用的 object
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 將 freeIndex 移到下 8 個 bytes
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">sfreeindex</span> = (<span style="color:#a6e22e">sfreeindex</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">64</span>) <span style="color:#f92672">&amp;^</span> (<span style="color:#ae81ff">64</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sfreeindex</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">snelems</span> { <span style="color:#75715e">// freeIndex 若超過此 mspan 總可用 object 數量，表示該 mspan 已無可用的 object
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> = <span style="color:#a6e22e">snelems</span>
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">snelems</span>
		}
		<span style="color:#a6e22e">whichByte</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sfreeindex</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">8</span>
		<span style="color:#75715e">// 根據新的 freeIndex 重新填補 allocCache
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">refillAllocCache</span>(<span style="color:#a6e22e">whichByte</span>)
		<span style="color:#a6e22e">aCache</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCache</span>
		<span style="color:#a6e22e">bitIndex</span> = <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">Ctz64</span>(<span style="color:#a6e22e">aCache</span>)
		<span style="color:#75715e">// nothing available in cached bits
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// grab the next 8 bytes and try again.
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sfreeindex</span> <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">bitIndex</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">snelems</span> {
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> = <span style="color:#a6e22e">snelems</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">snelems</span>
	}

	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCache</span> <span style="color:#f92672">&gt;&gt;=</span> uint(<span style="color:#a6e22e">bitIndex</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 調整 allocCache
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sfreeindex</span> = <span style="color:#a6e22e">result</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// 調整 freeIndex
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sfreeindex</span><span style="color:#f92672">%</span><span style="color:#ae81ff">64</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sfreeindex</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">snelems</span> {
		<span style="color:#75715e">// We just incremented s.freeindex so it isn&#39;t 0.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// As each 1 in s.allocCache was encountered and used for allocation
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// it was shifted away. At this point s.allocCache contains all 0s.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Refill s.allocCache so that it corresponds
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// to the bits at s.allocBits starting at s.freeindex.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">whichByte</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sfreeindex</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">8</span>
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">refillAllocCache</span>(<span style="color:#a6e22e">whichByte</span>)
	}
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> = <span style="color:#a6e22e">sfreeindex</span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
}</code></pre></div></p>
<p>若該 <code>mspan</code> 已無可用的 object 便呼叫 <code>refill</code> 向 <code>mcentral</code> 申請新的 <code>mspan</code> 替換舊的：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mcache.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mcache</span>) <span style="color:#a6e22e">refill</span>(<span style="color:#a6e22e">spc</span> <span style="color:#a6e22e">spanClass</span>) {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">alloc</span>[<span style="color:#a6e22e">spc</span>] <span style="color:#75715e">// 取出目前滿載的 mspan
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">if</span> uintptr(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;refill of span with free space remaining&#34;</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">emptymspan</span> {
		<span style="color:#75715e">// 將此 mspan 標記為不再被 mcache cached
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">sweepgen</span><span style="color:#f92672">+</span><span style="color:#ae81ff">3</span> {
			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;bad sweepgen in refill&#34;</span>)
		}
		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>, <span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">sweepgen</span>)
	}

	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">central</span>[<span style="color:#a6e22e">spc</span>].<span style="color:#a6e22e">mcentral</span>.<span style="color:#a6e22e">cacheSpan</span>() <span style="color:#75715e">// 從 mcentral 再拿一個新的 mspan
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;out of memory&#34;</span>)
	}

	<span style="color:#66d9ef">if</span> uintptr(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;span has no free space&#34;</span>)
	}

	<span style="color:#75715e">// Indicate that this span is cached and prevent asynchronous
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// sweeping in the next sweep phase.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span> = <span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">sweepgen</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>

	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">alloc</span>[<span style="color:#a6e22e">spc</span>] = <span style="color:#a6e22e">s</span> <span style="color:#75715e">// 將新的 mspan 放到 mcache 裡
</span><span style="color:#75715e"></span>}</code></pre></div></p>
<p>接著再看 <code>cacheSpan</code> 如何從 <code>mcentral</code> 拿出一個新的 <code>mspan</code> 放到 <code>mcache</code> 裡：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mcentral.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mcentral</span>) <span style="color:#a6e22e">cacheSpan</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> {
	<span style="color:#75715e">// Deduct credit for this span allocation and sweep if necessary.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spanBytes</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">class_to_allocnpages</span>[<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">spanclass</span>.<span style="color:#a6e22e">sizeclass</span>()]) <span style="color:#f92672">*</span> <span style="color:#a6e22e">_PageSize</span>
	<span style="color:#a6e22e">deductSweepCredit</span>(<span style="color:#a6e22e">spanBytes</span>, <span style="color:#ae81ff">0</span>)

	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>) <span style="color:#75715e">// mcentral 是共用的，需要 lock
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">traceDone</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceGCSweepStart</span>()
	}
	<span style="color:#a6e22e">sg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">sweepgen</span>
<span style="color:#a6e22e">retry</span>:
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>
    <span style="color:#75715e">// 試著在 nonempty mspan linked-list (還有可用 object 的 mspan) 找出可用的 mspan
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">nonempty</span>.<span style="color:#a6e22e">first</span>; <span style="color:#a6e22e">s</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">next</span> {
		<span style="color:#75715e">// sg-2 代表該 mspan 需要 sweep，試著將他的狀態改成 sg-1，即為該 mspan 正在被 swept
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>, <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">nonempty</span>.<span style="color:#a6e22e">remove</span>(<span style="color:#a6e22e">s</span>) <span style="color:#75715e">// 將該 mspan 從 nonempty 移除
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">empty</span>.<span style="color:#a6e22e">insertBack</span>(<span style="color:#a6e22e">s</span>) <span style="color:#75715e">// 將該 mspan insert 到 empty 的尾巴
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>) <span style="color:#75715e">// 找到可用的 mspan 了，可以 unlock mcentral 了
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweep</span>(<span style="color:#66d9ef">true</span>) <span style="color:#75715e">// sweep 該 mspan
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">havespan</span>
		}
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
			<span style="color:#75715e">// the span is being swept by background sweeper, skip
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#75715e">// 該 mspan 可以直接使用，不需 sweep，直接將他從 nonempty 移除，並 insert 到 empty 的尾巴
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">nonempty</span>.<span style="color:#a6e22e">remove</span>(<span style="color:#a6e22e">s</span>)
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">empty</span>.<span style="color:#a6e22e">insertBack</span>(<span style="color:#a6e22e">s</span>)
		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
		<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">havespan</span>
	}

    <span style="color:#75715e">// 試著在 empty mspan linked-list (已經沒有空間或被 cached 的 mspan) 找出可用的 mspan
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">empty</span>.<span style="color:#a6e22e">first</span>; <span style="color:#a6e22e">s</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">next</span> {
		<span style="color:#75715e">// 與上面一樣，找出需 sweep 的 mspan 並試著改他的狀態
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>, <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">empty</span>.<span style="color:#a6e22e">remove</span>(<span style="color:#a6e22e">s</span>)
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">empty</span>.<span style="color:#a6e22e">insertBack</span>(<span style="color:#a6e22e">s</span>)
            <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
            
            <span style="color:#75715e">// sweep 該 mspan
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweep</span>(<span style="color:#66d9ef">true</span>)

			<span style="color:#75715e">// 看看 swept 後的 mspan 的 freeIndex 是否可用
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">freeIndex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nextFreeIndex</span>()
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">freeIndex</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
				<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> = <span style="color:#a6e22e">freeIndex</span>
				<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">havespan</span>
			}
			<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)

			<span style="color:#75715e">// 該 mspan 在 swept 後還是空的，並且已經在 empty 裡了，直接 retry
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// 這裡我自己也不是很清楚為什麼是直接 retry，而不是繼續檢查 empty list 裡的其他 mspan
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">retry</span>
		}
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
			<span style="color:#75715e">// the span is being swept by background sweeper, skip
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#75715e">// already swept empty span,
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// all subsequent ones must also be either swept or in process of sweeping
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 上面是原文註解，但我依然不是很清楚為什麼這裡直接 break。
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 例如第一個 mspan 是不需要 sweep 的話 (單純滿了)，那便直接 break 不繼續檢查其他 mspan 了嗎？
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">break</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceGCSweepDone</span>()
		<span style="color:#a6e22e">traceDone</span> = <span style="color:#66d9ef">true</span>
	}
	<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)

	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">grow</span>() <span style="color:#75715e">// 在 nonempty 及 empty 都找不到可用的 mspan，需要向 mheap 申請
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	}
	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">empty</span>.<span style="color:#a6e22e">insertBack</span>(<span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)

	<span style="color:#75715e">// At this point s is a non-empty span, queued at the end of the empty list,
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// c is unlocked.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">havespan</span>:
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">traceDone</span> {
		<span style="color:#a6e22e">traceGCSweepDone</span>()
	}
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span>) <span style="color:#f92672">-</span> int(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> <span style="color:#f92672">||</span> uintptr(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;span has no free objects&#34;</span>)
	}
	<span style="color:#75715e">// Assume all objects from this span will be allocated in the
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// mcache. If it gets uncached, we&#39;ll adjust this.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">nmalloc</span>, int64(<span style="color:#a6e22e">n</span>))
	<span style="color:#a6e22e">usedBytes</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">elemsize</span>
	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_live</span>, int64(<span style="color:#a6e22e">spanBytes</span>)<span style="color:#f92672">-</span>int64(<span style="color:#a6e22e">usedBytes</span>))
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#75715e">// heap_live changed.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">traceHeapAlloc</span>()
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gcBlackenEnabled</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#75715e">// heap_live changed.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gcController</span>.<span style="color:#a6e22e">revise</span>()
	}
	<span style="color:#a6e22e">freeByteBase</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> <span style="color:#f92672">&amp;^</span> (<span style="color:#ae81ff">64</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">whichByte</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">freeByteBase</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">8</span>
	<span style="color:#75715e">// Init alloc bits cache.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">refillAllocCache</span>(<span style="color:#a6e22e">whichByte</span>)

	<span style="color:#75715e">// Adjust the allocCache so that s.freeindex corresponds to the low bit in
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// s.allocCache.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCache</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">64</span>

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
}</code></pre></div></p>
<p>上面是 <code>mcache</code> 向 <code>mcentral</code> 申請新的 <code>mspan</code>，如果 <code>mcentral</code> 也沒有，便呼叫 <code>grow</code> 向 <code>mheap</code> 申請：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mcentral.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mcentral</span>) <span style="color:#a6e22e">grow</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> {
	<span style="color:#75715e">// 根據該 mcentral 的 spanclass 計算要申請的量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">npages</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">class_to_allocnpages</span>[<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">spanclass</span>.<span style="color:#a6e22e">sizeclass</span>()])
	<span style="color:#a6e22e">size</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">class_to_size</span>[<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">spanclass</span>.<span style="color:#a6e22e">sizeclass</span>()])
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">npages</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">_PageShift</span>) <span style="color:#f92672">/</span> <span style="color:#a6e22e">size</span>

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">alloc</span>(<span style="color:#a6e22e">npages</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">spanclass</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>) <span style="color:#75715e">// 向 mheap 申請 mspan 來使用
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	}

	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>()
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">limit</span> = <span style="color:#a6e22e">p</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">*</span><span style="color:#a6e22e">n</span>

	<span style="color:#a6e22e">heapBitsForAddr</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>()).<span style="color:#a6e22e">initSpan</span>(<span style="color:#a6e22e">s</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
}</code></pre></div></p>
<p>繼續看 <code>alloc</code> 這個 function：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mheap.go
</span><span style="color:#75715e">// alloc allocates a new span of npage pages from the GC&#39;d heap.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Either large must be true or spanclass must indicates the span&#39;s
</span><span style="color:#75715e">// size class and scannability.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// If needzero is true, the memory for the returned span will be zeroed.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mheap</span>) <span style="color:#a6e22e">alloc</span>(<span style="color:#a6e22e">npage</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">spanclass</span> <span style="color:#a6e22e">spanClass</span>, <span style="color:#a6e22e">large</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> {
	<span style="color:#75715e">// Don&#39;t do any operations that lock the heap on the G stack.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// It might trigger stack growth, and the stack growth code needs
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// to be able to allocate heap.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>
	<span style="color:#a6e22e">systemstack</span>(<span style="color:#66d9ef">func</span>() {
		<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">alloc_m</span>(<span style="color:#a6e22e">npage</span>, <span style="color:#a6e22e">spanclass</span>, <span style="color:#a6e22e">large</span>) <span style="color:#75715e">// 呼叫 alloc_m 申請 mspan
</span><span style="color:#75715e"></span>	})

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">needzero</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">needzero</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">memclrNoHeapPointers</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>()), <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#a6e22e">_PageShift</span>)
		}
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">needzero</span> = <span style="color:#ae81ff">0</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
}</code></pre></div></p>
<p>繼續看 <code>alloc_m</code> 這個 function:<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mheap.go
</span><span style="color:#75715e">// alloc_m is the internal implementation of mheap.alloc.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// alloc_m must run on the system stack because it locks the heap, so
</span><span style="color:#75715e">// any stack growth during alloc_m would self-deadlock.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//go:systemstack
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mheap</span>) <span style="color:#a6e22e">alloc_m</span>(<span style="color:#a6e22e">npage</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">spanclass</span> <span style="color:#a6e22e">spanClass</span>, <span style="color:#a6e22e">large</span> <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> {
	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

	<span style="color:#75715e">// 為了避免 heap 長太快，會先試著先回收一些 page 回來
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">sweepdone</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">reclaim</span>(<span style="color:#a6e22e">npage</span>)
	}

	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">lock</span>)
	<span style="color:#75715e">// transfer stats from cache to global
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_scan</span> <span style="color:#f92672">+=</span> uint64(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span>.<span style="color:#a6e22e">local_scan</span>)
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span>.<span style="color:#a6e22e">local_scan</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">tinyallocs</span> <span style="color:#f92672">+=</span> uint64(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span>.<span style="color:#a6e22e">local_tinyallocs</span>)
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span>.<span style="color:#a6e22e">local_tinyallocs</span> = <span style="color:#ae81ff">0</span>

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">allocSpanLocked</span>(<span style="color:#a6e22e">npage</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_inuse</span>) <span style="color:#75715e">// 從 mheap 裡分配 mspan
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#75715e">// 成功分配 mspan 的話，便更新該 mspan 的一些資訊
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Record span info, because gc needs to be
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// able to map interior pointer to containing span.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">sweepgen</span>)
		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">sweepSpans</span>[<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">sweepgen</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span><span style="color:#f92672">%</span><span style="color:#ae81ff">2</span>].<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">s</span>) <span style="color:#75715e">// Add to swept in-use list.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">mSpanInUse</span>
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span> = <span style="color:#ae81ff">0</span>
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">spanclass</span> = <span style="color:#a6e22e">spanclass</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sizeclass</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">spanclass</span>.<span style="color:#a6e22e">sizeclass</span>(); <span style="color:#a6e22e">sizeclass</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">elemsize</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">_PageShift</span>
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">divShift</span> = <span style="color:#ae81ff">0</span>
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">divMul</span> = <span style="color:#ae81ff">0</span>
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">divShift2</span> = <span style="color:#ae81ff">0</span>
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">baseMask</span> = <span style="color:#ae81ff">0</span>
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">elemsize</span> = uintptr(<span style="color:#a6e22e">class_to_size</span>[<span style="color:#a6e22e">sizeclass</span>])
			<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">class_to_divmagic</span>[<span style="color:#a6e22e">sizeclass</span>]
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">divShift</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">shift</span>
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">divMul</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mul</span>
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">divShift2</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">shift2</span>
			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">baseMask</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">baseMask</span>
		}

		<span style="color:#75715e">// Mark in-use span in arena page bitmap.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">arena</span>, <span style="color:#a6e22e">pageIdx</span>, <span style="color:#a6e22e">pageMask</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pageIndexOf</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>())
		<span style="color:#a6e22e">arena</span>.<span style="color:#a6e22e">pageInUse</span>[<span style="color:#a6e22e">pageIdx</span>] <span style="color:#f92672">|=</span> <span style="color:#a6e22e">pageMask</span>

		<span style="color:#75715e">// update stats, sweep lists
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">pagesInUse</span> <span style="color:#f92672">+=</span> uint64(<span style="color:#a6e22e">npage</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">large</span> {
			<span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_objects</span><span style="color:#f92672">++</span>
			<span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">largealloc</span> <span style="color:#f92672">+=</span> uint64(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">elemsize</span>)
			<span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">nlargealloc</span><span style="color:#f92672">++</span>
			<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_live</span>, int64(<span style="color:#a6e22e">npage</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#a6e22e">_PageShift</span>))
		}
	}
	<span style="color:#75715e">// heap_scan and heap_live were updated.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gcBlackenEnabled</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">gcController</span>.<span style="color:#a6e22e">revise</span>()
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceHeapAlloc</span>()
	}

	<span style="color:#75715e">// h.spans is accessed concurrently without synchronization
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// from other threads. Hence, there must be a store/store
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// barrier here to ensure the writes to h.spans above happen
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// before the caller can publish a pointer p to an object
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// allocated from s. As soon as this happens, the garbage
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// collector running on another processor could read p and
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// look up s in h.spans. The unlock acts as the barrier to
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// order these writes. On the read side, the data dependency
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// between p and the index in h.spans orders the reads.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">lock</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
}</code></pre></div></p>
<p>再來重點是 <code>allocSpanLocked</code> 這個 function：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mheap.go
</span><span style="color:#75715e">// Allocates a span of the given size.  h must be locked.
</span><span style="color:#75715e">// The returned span has been removed from the
</span><span style="color:#75715e">// free structures, but its state is still mSpanFree.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mheap</span>) <span style="color:#a6e22e">allocSpanLocked</span>(<span style="color:#a6e22e">npage</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">stat</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uint64</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>

	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">pickFreeSpan</span>(<span style="color:#a6e22e">npage</span>) <span style="color:#75715e">// 從 mheap 裡找出可用的 mspan，找不到則回傳 nil
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">HaveSpan</span> <span style="color:#75715e">// 成功找到可用的 mspan，跳到 HaveSpan section
</span><span style="color:#75715e"></span>	}
	<span style="color:#75715e">// 若找不到可用的 mspan，便增加 heap 後再試一次
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">grow</span>(<span style="color:#a6e22e">npage</span>) {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// 增加 heap 失敗，某個地方出了嚴重的錯誤，直接 return nil
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">pickFreeSpan</span>(<span style="color:#a6e22e">npage</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">HaveSpan</span>
	}
	<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;grew heap, but no adequate free span found&#34;</span>)

<span style="color:#a6e22e">HaveSpan</span>:
	<span style="color:#75715e">// Mark span in use.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">state</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">mSpanFree</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;candidate mspan for allocation is not free&#34;</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span> &lt; <span style="color:#a6e22e">npage</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;candidate mspan for allocation is too small&#34;</span>)
	}

	<span style="color:#75715e">// First, subtract any memory that was released back to
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// the OS from s. We will re-scavenge the trimmed section
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// if necessary.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_released</span> <span style="color:#f92672">-=</span> uint64(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">released</span>())

	<span style="color:#75715e">// pickFreeSpan 這個 function 會找出最小可容納 npage 的 mspan，所以找到的 mspan 大小可能超過 npage，
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 此時會將多餘的空間切掉還回去給 heap，只拿需要的大小就好
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span> &gt; <span style="color:#a6e22e">npage</span> {
		<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>)(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">spanalloc</span>.<span style="color:#a6e22e">alloc</span>()) <span style="color:#75715e">// 分配 mspan 的結構
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">init</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>()<span style="color:#f92672">+</span><span style="color:#a6e22e">npage</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#a6e22e">_PageShift</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span><span style="color:#f92672">-</span><span style="color:#a6e22e">npage</span>) <span style="color:#75715e">// 把多出來的空間 initialize 成一個新的 mspan
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span> = <span style="color:#a6e22e">npage</span>
		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">setSpan</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">base</span>()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">s</span>)
		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">setSpan</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">base</span>(), <span style="color:#a6e22e">t</span>)
		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">setSpan</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">base</span>()<span style="color:#f92672">+</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">npages</span><span style="color:#f92672">*</span><span style="color:#a6e22e">pageSize</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">t</span>)
		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">needzero</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">needzero</span>
		<span style="color:#75715e">// 若 s 是 scanvenged，則 t 也有可能是
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">physPageBounds</span>()
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">scavenged</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">start</span> &lt; <span style="color:#a6e22e">end</span> {
			<span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_released</span> <span style="color:#f92672">+=</span> uint64(<span style="color:#a6e22e">end</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">start</span>)
			<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">scavenged</span> = <span style="color:#66d9ef">true</span>
		}
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">mSpanManual</span> <span style="color:#75715e">// prevent coalescing with s
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">mSpanManual</span>
		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">freeSpanLocked</span>(<span style="color:#a6e22e">t</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">unusedsince</span>) <span style="color:#75715e">// 將 t (用多出來的空間新成立的 mspan) 還回去 mheap (放入 mheap.free)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">mSpanFree</span>
	}
	<span style="color:#75715e">// &#34;Unscavenge&#34; s only AFTER splitting so that
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// we only sysUsed whatever we actually need.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">scavenged</span> {
		<span style="color:#75715e">// sysUsed all the pages that are actually available
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// in the span. Note that we don&#39;t need to decrement
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// heap_released since we already did so earlier.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">sysUsed</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>()), <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#a6e22e">_PageShift</span>)
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">scavenged</span> = <span style="color:#66d9ef">false</span>
	}
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">unusedsince</span> = <span style="color:#ae81ff">0</span>

	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">setSpans</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>(), <span style="color:#a6e22e">npage</span>, <span style="color:#a6e22e">s</span>)  <span style="color:#75715e">// 更新 mheap 裡的 spans 資訊
</span><span style="color:#75715e"></span>
	<span style="color:#f92672">*</span><span style="color:#a6e22e">stat</span> <span style="color:#f92672">+=</span> uint64(<span style="color:#a6e22e">npage</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">_PageShift</span>)
	<span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_idle</span> <span style="color:#f92672">-=</span> uint64(<span style="color:#a6e22e">npage</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">_PageShift</span>)

	<span style="color:#75715e">//println(&#34;spanalloc&#34;, hex(s.start&lt;&lt;_PageShift))
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">inList</span>() {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;still in list&#34;</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
}</code></pre></div></p>
<p>接著 <code>pickFreeSpan</code> 這個 function 來得知 <code>mheap</code> 怎麼找出可用的 <code>mspan</code>：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mheap.go
</span><span style="color:#75715e">// pickFreeSpan acquires a free span from internal free list
</span><span style="color:#75715e">// structures if one is available. Otherwise returns nil.
</span><span style="color:#75715e">// h must be locked.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mheap</span>) <span style="color:#a6e22e">pickFreeSpan</span>(<span style="color:#a6e22e">npage</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> {
	<span style="color:#75715e">// free 及 scav 是樹堆 (tree+heap=treap)，其 priority 是 mspan 的 pages
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tf</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">free</span>.<span style="color:#a6e22e">find</span>(<span style="color:#a6e22e">npage</span>) <span style="color:#75715e">// 找出最小且可容納 npage 大小的 mspan
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">scav</span>.<span style="color:#a6e22e">find</span>(<span style="color:#a6e22e">npage</span>) <span style="color:#75715e">// 找出最小且可容納 npage 大小的 mspan
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// 看誰給我們的 mspan 不為 nil 且比較接近 npage
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tf</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#a6e22e">ts</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">tf</span>.<span style="color:#a6e22e">spanKey</span>.<span style="color:#a6e22e">npages</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">ts</span>.<span style="color:#a6e22e">spanKey</span>.<span style="color:#a6e22e">npages</span>) {
		<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">tf</span>.<span style="color:#a6e22e">spanKey</span> <span style="color:#75715e">// treap node 裡的 spanKey 就是 mspan 的 pointer
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">free</span>.<span style="color:#a6e22e">removeNode</span>(<span style="color:#a6e22e">tf</span>) <span style="color:#75715e">// 移除該 treap node
</span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ts</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#a6e22e">tf</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">tf</span>.<span style="color:#a6e22e">spanKey</span>.<span style="color:#a6e22e">npages</span> &gt; <span style="color:#a6e22e">ts</span>.<span style="color:#a6e22e">spanKey</span>.<span style="color:#a6e22e">npages</span>) {
		<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">ts</span>.<span style="color:#a6e22e">spanKey</span>
		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">scav</span>.<span style="color:#a6e22e">removeNode</span>(<span style="color:#a6e22e">ts</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
}</code></pre></div></p>
<p>最後一個 function 了！當 <code>mheap</code> 空間不夠時，會呼叫 <code>grow</code> 向 OS 申請空間：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// mheap.go
</span><span style="color:#75715e">// Try to add at least npage pages of memory to the heap,
</span><span style="color:#75715e">// returning whether it worked.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// h must be locked.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mheap</span>) <span style="color:#a6e22e">grow</span>(<span style="color:#a6e22e">npage</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#a6e22e">ask</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">npage</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">_PageShift</span> <span style="color:#75715e">// 將想申請的頁數轉換成 bytes
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">size</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">sysAlloc</span>(<span style="color:#a6e22e">ask</span>) <span style="color:#75715e">// 向 OS 申請空間
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		print(<span style="color:#e6db74">&#34;runtime: out of memory: cannot allocate &#34;</span>, <span style="color:#a6e22e">ask</span>, <span style="color:#e6db74">&#34;-byte block (&#34;</span>, <span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">heap_sys</span>, <span style="color:#e6db74">&#34; in use)\n&#34;</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}

	<span style="color:#75715e">// Scavenge some pages out of the free treap to make up for
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// the virtual memory space we just allocated. We prefer to
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// scavenge the largest spans first since the cost of scavenging
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// is proportional to the number of sysUnused() calls rather than
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// the number of pages released, so we make fewer of those calls
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// with larger spans.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">scavengeLargest</span>(<span style="color:#a6e22e">size</span>)

	<span style="color:#75715e">// Create a fake &#34;in use&#34; span and free it, so that the
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// right coalescing happens.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>)(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">spanalloc</span>.<span style="color:#a6e22e">alloc</span>()) <span style="color:#75715e">// 分配 mspan 結構
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">init</span>(uintptr(<span style="color:#a6e22e">v</span>), <span style="color:#a6e22e">size</span><span style="color:#f92672">/</span><span style="color:#a6e22e">pageSize</span>) <span style="color:#75715e">// 根據得到的位址 initialize 一個新的 mspan
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">setSpans</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>(), <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span>, <span style="color:#a6e22e">s</span>) <span style="color:#75715e">// 更新 mheap.spans 的資訊，即哪個 page 對應到哪個 mspan
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">sweepgen</span>)
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">mSpanInUse</span>
	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">pagesInUse</span> <span style="color:#f92672">+=</span> uint64(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">npages</span>)
	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">freeSpanLocked</span>(<span style="color:#a6e22e">s</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// 將該 mspan 插入 mheap.free 裡
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span> <span style="color:#75715e">// return true 表示成功向 OS 申請空間
</span><span style="color:#75715e"></span>}</code></pre></div></p>
<h2 id="small-size">Small Size</h2>
<p><a href="https://github.com/golang/go/blob/go1.12.5/src/runtime/malloc.go#L928">Source code</a></p>
<p>Small size 分配流程大致如下：</p>
<ol>
<li>根據需求確定其 size class 及 span class</li>
<li>試著從 <code>mcache</code> 找可用的 object，有的話便直接分配</li>
<li>若沒有則向 <code>mcentral</code> 要一個 <code>mspan</code></li>
<li>若 <code>mcentral</code> 也沒有，則會再向 <code>mheap</code> 申請</li>
</ol>
<p>上述行為到第 2 步為止都不需 lock，第 3、4 步都需要 lock，分別 lock 住 <code>mcentral</code> 及 <code>mheap</code>。</p>
<p>下列是 small size allocating 的部份內容：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// malloc.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">typ</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
	<span style="color:#75715e">// 處理 GC 相關事情
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">maxSmallSize</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">noscan</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">size</span> &lt; <span style="color:#a6e22e">maxTinySize</span> {
			<span style="color:#75715e">// tiny size 分配流程
</span><span style="color:#75715e"></span>		} <span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// 根據要分配的 size 找出合適的 size class
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sizeclass</span> <span style="color:#66d9ef">uint8</span>
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">smallSizeMax</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span> {
				<span style="color:#a6e22e">sizeclass</span> = <span style="color:#a6e22e">size_to_class8</span>[(<span style="color:#a6e22e">size</span><span style="color:#f92672">+</span><span style="color:#a6e22e">smallSizeDiv</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#a6e22e">smallSizeDiv</span>]
			} <span style="color:#66d9ef">else</span> {
				<span style="color:#a6e22e">sizeclass</span> = <span style="color:#a6e22e">size_to_class128</span>[(<span style="color:#a6e22e">size</span><span style="color:#f92672">-</span><span style="color:#a6e22e">smallSizeMax</span><span style="color:#f92672">+</span><span style="color:#a6e22e">largeSizeDiv</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#a6e22e">largeSizeDiv</span>]
			}

			<span style="color:#a6e22e">size</span> = uintptr(<span style="color:#a6e22e">class_to_size</span>[<span style="color:#a6e22e">sizeclass</span>]) <span style="color:#75715e">// 將 size round up 為此 class 的 object size
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">spc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">makeSpanClass</span>(<span style="color:#a6e22e">sizeclass</span>, <span style="color:#a6e22e">noscan</span>) <span style="color:#75715e">// 根據 size class 及是否能 scan 決定 span class
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">span</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">alloc</span>[<span style="color:#a6e22e">spc</span>] <span style="color:#75715e">// 根據 span class 取出 mcache 裡的 mspan
</span><span style="color:#75715e"></span>
			<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nextFreeFast</span>(<span style="color:#a6e22e">span</span>) <span style="color:#75715e">// 利用 mspan.allocCache 快裡找出可用的 object (回頭看上面的 tiny size 流程)
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">span</span>, <span style="color:#a6e22e">shouldhelpgc</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">nextFree</span>(<span style="color:#a6e22e">spc</span>) <span style="color:#75715e">// 找不到的話，便試著從整個 mspan 找出可用的 object (回頭看上面的 tiny size 流程)
</span><span style="color:#75715e"></span>			}
			<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">v</span>)
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">needzero</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">span</span>.<span style="color:#a6e22e">needzero</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#a6e22e">memclrNoHeapPointers</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">v</span>), <span style="color:#a6e22e">size</span>)
			}
		}
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#75715e">// large size 分配流程
</span><span style="color:#75715e"></span>	}

	<span style="color:#75715e">// 後續處理
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
}</code></pre></div></p>
<p>額外看一下 <code>makeSpanClass</code>：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeSpanClass</span>(<span style="color:#a6e22e">sizeclass</span> <span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">noscan</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">spanClass</span> {
	<span style="color:#75715e">// 可以看到 size class 與 span class 的轉換方式其實就是將 size class * 2 再根據是否為 pointer 加 0 或 1
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">spanClass</span>(<span style="color:#a6e22e">sizeclass</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>) | <span style="color:#a6e22e">spanClass</span>(<span style="color:#a6e22e">bool2int</span>(<span style="color:#a6e22e">noscan</span>))
}</code></pre></div></p>
<h2 id="large-size">Large Size</h2>
<p><a href="https://github.com/golang/go/blob/go1.12.5/src/runtime/malloc.go#L947">Source code</a></p>
<p>Large size 分配流程相對簡單，跳過 <code>mcache</code> 及 <code>mcentral</code> 直接透過 <code>mheap</code> 向 OS 申請需要的空間。</p>
<p>下列是 large size allocating 的 部份內容：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// malloc.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">typ</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
	<span style="color:#75715e">// 處理 GC 相關事情
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">maxSmallSize</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">noscan</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">size</span> &lt; <span style="color:#a6e22e">maxTinySize</span> {
			<span style="color:#75715e">// tiny size 分配流程
</span><span style="color:#75715e"></span>		} <span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// small size 分配流程
</span><span style="color:#75715e"></span>		}
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>
		<span style="color:#a6e22e">shouldhelpgc</span> = <span style="color:#66d9ef">true</span>
		<span style="color:#a6e22e">systemstack</span>(<span style="color:#66d9ef">func</span>() {
			
			<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">largeAlloc</span>(<span style="color:#a6e22e">size</span>, <span style="color:#a6e22e">needzero</span>, <span style="color:#a6e22e">noscan</span>) <span style="color:#75715e">// 呼叫 largeAlloc
</span><span style="color:#75715e"></span>		})
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> = <span style="color:#ae81ff">1</span>
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCount</span> = <span style="color:#ae81ff">1</span>
		<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>())
		<span style="color:#a6e22e">size</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">elemsize</span>
	}

	<span style="color:#75715e">// 後續處理
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
}</code></pre></div></p>
<p>接著看 <code>largeAlloc</code> 這個 function：<br>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// malloc.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">largeAlloc</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">noscan</span> <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> {
	<span style="color:#75715e">// print(&#34;largeAlloc size=&#34;, size, &#34;\n&#34;)
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">+</span><span style="color:#a6e22e">_PageSize</span> &lt; <span style="color:#a6e22e">size</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;out of memory&#34;</span>)
	}
	<span style="color:#a6e22e">npages</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#a6e22e">_PageShift</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">_PageMask</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">npages</span><span style="color:#f92672">++</span>
	}

	<span style="color:#75715e">// Deduct credit for this span allocation and sweep if
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// necessary. mHeap_Alloc will also sweep npages, so this only
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// pays the debt down to npage pages.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">deductSweepCredit</span>(<span style="color:#a6e22e">npages</span><span style="color:#f92672">*</span><span style="color:#a6e22e">_PageSize</span>, <span style="color:#a6e22e">npages</span>)

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">alloc</span>(<span style="color:#a6e22e">npages</span>, <span style="color:#a6e22e">makeSpanClass</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">noscan</span>), <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">needzero</span>) <span style="color:#75715e">// 跳過 mcache、mcentral，直接向 mheap 申請 (回頭看上面的 tiny size 流程)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;out of memory&#34;</span>)
	}
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">limit</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">size</span>
	<span style="color:#a6e22e">heapBitsForAddr</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">base</span>()).<span style="color:#a6e22e">initSpan</span>(<span style="color:#a6e22e">s</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
}</code></pre></div></p>
<h2 id="flow-chart">Flow Chart</h2>
<p>搭配底下的圖片可知整個 Golang 的分配流程是有層級的。事先向 OS 申請一大塊連續的虛擬記憶體，再切割成各種粒度的 mspan 來分配。<br>
只要能弄懂 tiny allocation 的流程，剩下的 small 及 large 便也能理解了，他們其實都是重覆一樣的動作而已。<br>
<img src="https://chihkaiyu.github.io/content/images/2019/07/golang-memory-allocating-flow.png" alt=""></p>
<h1 id="reference">Reference</h1>
<ul>
<li><a href="https://speakerdeck.com/emfree/allocator-wrestling">https://speakerdeck.com/emfree/allocator-wrestling</a></li>
<li><a href="https://blog.ankuranand.com/2019/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/">https://blog.ankuranand.com/2019/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/</a></li>
<li><a href="https://xenojoshua.com/2019/03/golang-memory/#234-%E5%AF%B9%E8%B1%A1%E5%B0%BA%E5%AF%B8%E5%88%86%E7%BA%A7">https://xenojoshua.com/2019/03/golang-memory/#234-%E5%AF%B9%E8%B1%A1%E5%B0%BA%E5%AF%B8%E5%88%86%E7%BA%A7</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1422392">https://cloud.tencent.com/developer/article/1422392</a></li>
<li><a href="http://legendtkl.com/2017/04/02/golang-alloc/">http://legendtkl.com/2017/04/02/golang-alloc/</a></li>
<li><a href="https://faaaar.github.io/2019/06/05/go/memory-allocation/">https://faaaar.github.io/2019/06/05/go/memory-allocation/</a></li>
<li><a href="https://andrestc.com/post/go-memory-allocation-pt1/">https://andrestc.com/post/go-memory-allocation-pt1/</a></li>
<li><a href="https://www.cnblogs.com/zkweb/p/7880099.html">https://www.cnblogs.com/zkweb/p/7880099.html</a></li>
<li><a href="http://lessisbetter.site/2019/07/06/go-memory-allocation/">http://lessisbetter.site/2019/07/06/go-memory-allocation/</a></li>
<li><a href="https://programmer.help/blogs/exploration-of-golang-source-code-3-realization-principle-of-gc.html">https://programmer.help/blogs/exploration-of-golang-source-code-3-realization-principle-of-gc.html</a></li>
<li><a href="https://kknews.cc/zh-tw/code/5rbk9kk.html">https://kknews.cc/zh-tw/code/5rbk9kk.html</a></li>
</ul>

</div>

<h2>Comments</h2>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "chihkaiyu" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </main>

    
      
    
  </body>
</html>
