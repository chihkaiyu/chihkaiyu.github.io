<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on No Idiots Allowed Here</title>
    <link>https://chihkaiyu.github.io/post/</link>
    <description>Recent content in Posts on No Idiots Allowed Here</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-TW</language>
    <lastBuildDate>Fri, 27 Dec 2019 00:53:00 +0800</lastBuildDate>
    
	<atom:link href="https://chihkaiyu.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to Pachinko (パチンコ)</title>
      <link>https://chihkaiyu.github.io/post/introduction-to-pachinko/</link>
      <pubDate>Fri, 27 Dec 2019 00:53:00 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/introduction-to-pachinko/</guid>
      <description>Introduction to Pachinko (パチンコ) 此文介紹柏青哥機台上各按鈕的功能，以及基本玩法。 柏青哥一開始是給小孩子玩的遊戲機，後來第二次世界大戰結束後，因為有大量的鋼</description>
    </item>
    
    <item>
      <title>Why Quick Sort Is Faster than Heap Sort?</title>
      <link>https://chihkaiyu.github.io/post/why-quick-sort-is-faster-than-heap-sort/</link>
      <pubDate>Wed, 02 Oct 2019 01:10:00 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/why-quick-sort-is-faster-than-heap-sort/</guid>
      <description>Why Quick Sort? I was reviewing sorting algorithm for my interview. The question just popped up in my mind when I was peeking the cheat sheet.
[1]
You can see the best, average and worst time complexity of heap sort are all O(n logn) but it&amp;rsquo;s O(n^2) for worst of quick sort.
Then why do we always use quick sort? Since quick sort can&amp;rsquo;t beat heap sort in any cases, not even in space complexity.</description>
    </item>
    
    <item>
      <title>Golang Memory Management (based on 1.12.5)</title>
      <link>https://chihkaiyu.github.io/post/golang-memory-management/</link>
      <pubDate>Tue, 02 Jul 2019 00:03:00 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/golang-memory-management/</guid>
      <description>Golang Memory Management (based on 1.12.5) 此文是我在看過許多 Golang 記憶體管理的文章後，再搭配 souce code 所整理出來的。有點像是利用 souce code 來驗證我是否理解網路上所搜尋到的文章。 Golang 基於 TCMalloc (Thread-Caching</description>
    </item>
    
    <item>
      <title>Chapter VI - Big O</title>
      <link>https://chihkaiyu.github.io/post/chapter-vi-big-o/</link>
      <pubDate>Thu, 07 Mar 2019 00:24:00 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/chapter-vi-big-o/</guid>
      <description>Chapter VI - Big O Big O, Big Theta, and Big Omega 學術上使用 big O, big theta, big omega 來描述執行速度。然而工程上 (或是面試)，人們常會將 big theta 及 big O 混在一起。工程上的 big O 即是學術上的</description>
    </item>
    
    <item>
      <title>Prometheus Survey</title>
      <link>https://chihkaiyu.github.io/post/prometheus-survey/</link>
      <pubDate>Tue, 15 Jan 2019 22:16:00 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/prometheus-survey/</guid>
      <description>Prometheus Survey Architecture Prometheus server 負責蒐集及儲存各 target 的 metrics，也會檢查 alert 規則，觸發後會發 alert 給 alertmanager。 Target 要被監控的目標，會以網頁方式將 metrics 以固</description>
    </item>
    
    <item>
      <title>Clean Code Digest - Chapter 6 物件及資料結構</title>
      <link>https://chihkaiyu.github.io/post/clean-code-chapter-6/</link>
      <pubDate>Fri, 19 Oct 2018 01:15:38 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/clean-code-chapter-6/</guid>
      <description>Chapter 6 物件及資料結構 TL; DR 我認為此章節所想表達的有下列事項： 抽象化：資料需要抽象化隱藏其實作過程。在封裝起來後要依然能操作資料的本質。 互補：以資</description>
    </item>
    
    <item>
      <title>Clean Code Digest - Chapter 5 編排</title>
      <link>https://chihkaiyu.github.io/post/clean-code-chapter-5/</link>
      <pubDate>Thu, 11 Oct 2018 00:49:10 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/clean-code-chapter-5/</guid>
      <description>Chapter 5 編排 TL; DR 我認為此章節所想表達的有下列事項： 編排的目的：作者認為編排會影響可讀性，而可讀性會不斷對日後的改變產生影響。甚至整本書其實都是在</description>
    </item>
    
    <item>
      <title>Clean Code Digest - Chapter 4 註解</title>
      <link>https://chihkaiyu.github.io/post/clean-code-chapter-4/</link>
      <pubDate>Wed, 10 Oct 2018 14:33:00 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/clean-code-chapter-4/</guid>
      <description>Chapter 4 註解 TL; DR 我認為此章節所想表達的有下列事項： 最後一道防線：作者認為註解是最後手段，在寫下註解前，你應該好好的審視程式碼是否能改寫得更好，盡</description>
    </item>
    
    <item>
      <title>Clean Code Digest - Chapter 3 函式</title>
      <link>https://chihkaiyu.github.io/post/clean-code-chapter-3/</link>
      <pubDate>Thu, 27 Sep 2018 23:18:56 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/clean-code-chapter-3/</guid>
      <description>Chapter 3 函式 TL; DR 我認為此章節所想表達的有下列事項： 簡短：整章其實都圍繞著「簡短」打轉，像是函式只做一件事，且是同一層抽象概念的事，一直到不要重複</description>
    </item>
    
    <item>
      <title>Clean Code Digest - Chapter 2 有意義的命名</title>
      <link>https://chihkaiyu.github.io/post/clean-code-chapter-2/</link>
      <pubDate>Wed, 19 Sep 2018 22:51:00 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/clean-code-chapter-2/</guid>
      <description>Chapter 2 有意義的命名 TL; DR 我認為此章節所想表達的有下列事項： 意圖：取一個好名稱便能得知此類別、物件、函式、變數的含義，或是它想要做什麼事、被做什麼</description>
    </item>
    
    <item>
      <title>Walkthrough Gitlab</title>
      <link>https://chihkaiyu.github.io/post/walkthrough-gitlab/</link>
      <pubDate>Fri, 29 Jun 2018 20:03:20 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/walkthrough-gitlab/</guid>
      <description>這份文件會告讓你怎麼設定一個 GitLab project 以及到哪裡找到相關的官方文件。這份文件的順序是按照 GitLab project 左側的 sidebar撰寫，如果有項目不在你的 project 裡，有可</description>
    </item>
    
    <item>
      <title>Migrate sameersbn/docker-gitlab to gitlab/gitlab-ce</title>
      <link>https://chihkaiyu.github.io/post/migrate-sameersbn-docker-gitlab-to-gitlab-gitlab-ce/</link>
      <pubDate>Tue, 12 Jun 2018 17:15:55 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/migrate-sameersbn-docker-gitlab-to-gitlab-gitlab-ce/</guid>
      <description>This article records how I migrate GitLab from sameersbn/gitlab to gitlab/gitlab-ce.
Why Why would I bother to migrate it? There are several reasons and here are the most important (for me) ones.
 If you want to enable some functions in GitLab, you would search it from official documents and here comes the pain: you don’t know how to configure it in sameersbn/gitlab. Though the documents of sameersbn/gitlab are quite good, it&amp;rsquo;s sometimes hard to mapping them together sameersbn/gitlab is driven by community and you don’t know when it would give up maintaining it (for the record, sameersbn/docker-gitlab is a excellent project.</description>
    </item>
    
    <item>
      <title>How to Install Ghost with Nginx and MySQL</title>
      <link>https://chihkaiyu.github.io/post/how-to-set-up-ghost-site-with-https/</link>
      <pubDate>Sat, 19 May 2018 23:33:58 +0800</pubDate>
      
      <guid>https://chihkaiyu.github.io/post/how-to-set-up-ghost-site-with-https/</guid>
      <description>This article will show you how to install and configure Ghost with Nginx and MySQL. In fact, it is that how this blog has been built. This article contains:
 Prerequisite Environment Ghost configuration Nginx configuration MySQL configuration Docker Compose Summary  Prerequisite I use Docker for handling my environment information and I suppose you have the basic knowledge about Docker and Docker Compose. Before you continue, you must ensure both of Docker and Docker Compose have been installed on your machine.</description>
    </item>
    
  </channel>
</rss>