<!DOCTYPE html>
<html lang="zh-TW">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    <meta name="twitter:card" content="summary"/>
    
    <meta name="twitter:image" content="/images/DSC03509.jpg"/>
    



<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>
<meta name="twitter:site" content="@kai_chihkaiyu"/>



  	<meta property="og:title" content="Posts &middot; No Idiots Allowed Here" />
  	<meta property="og:site_name" content="No Idiots Allowed Here" />
  	<meta property="og:url" content="https://chihkaiyu.github.io/post/" />

    
        
            <meta property="og:image" content="/images/DSC03509.jpg"/>
        
    

    
    <meta property="og:type" content="website" />
    <meta property="og:description" content="" />
    

    <title>Posts &middot; No Idiots Allowed Here</title>

    
    <meta name="description" content="" />
    

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://chihkaiyu.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://chihkaiyu.github.io/images/apple-touch-icon.png" />

    <link rel="stylesheet" type="text/css" href="https://chihkaiyu.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://chihkaiyu.github.io/css/nav.css" />

    

    
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
        
        <script>hljs.initHighlightingOnLoad();</script>
    

    
      
          <link href="https://chihkaiyu.github.io/index.xml" rel="alternate" type="application/rss+xml" title="No Idiots Allowed Here" />
      
      
        <link href="https://chihkaiyu.github.io/post/index.xml" rel="alternate" type="application/rss+xml" title="Posts &middot; No Idiots Allowed Here" />
      
    
    <meta name="generator" content="Hugo 0.53" />

    <link rel="canonical" href="https://chihkaiyu.github.io/post/" />

    
      
    
    <script type="application/ld+json">
    {
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Person",
        "name": ,
        
        "image": {
            "@type": "ImageObject",
            "url": https://chihkaiyu.github.ioimages/profile.png,
            "width": 250,
            "height": 250
        },
        
        "url": https://chihkaiyu.github.io,
        "sameAs": [
            
            
             
             
             
             
             
            
        ],
        "description": Software Engineer
        
    },
    "url": https://chihkaiyu.github.io,
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": https://chihkaiyu.github.io
    },
    "description": 
}
  </script>
    


    

    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-132491233-1', 'auto');
      ga('send', 'pageview');

    </script>
    

    

    <script data-ad-client="ca-pub-4265977316103171" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://chihkaiyu.github.io/">Home</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://chihkaiyu.github.io/page/about">About</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://chihkaiyu.github.io/post">Archives</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://chihkaiyu.github.io/page/tags">Tags</a>
            </li>
        
        
    </ul>

    
    <a class="subscribe-button icon-feed" href="https://chihkaiyu.github.io/post/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




	 
  <header class="main-header tag-head" style="background-image: url(/images/DSC03509.jpg)">
  

    <nav class="main-nav overlay clearfix">
      
        <a class="blog-logo" href="https://chihkaiyu.github.io"><img src="https://chihkaiyu.github.io/images/profile.png" alt="Home" /></a>
      
      
          <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">Menu</span></a>
      
    </nav>
    <div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">Posts</h1>
            <h2 class="page-description">
                
            </h2>
        </div>
    </div>
</header>

<main class="content" role="main">
    

	<div class="extra-pagination inner">
    <nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 2</span>
	
	    <a class="older-posts" href="https://chihkaiyu.github.io/post/page/2/">Older Posts &rarr;</a>
	
</nav>

	</div>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/introduction-to-pachinko/">Introduction to Pachinko (パチンコ)</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Introduction to Pachinko (パチンコ) 此文介紹柏青哥機台上各按鈕的功能，以及基本玩法。
柏青哥一開始是給小孩子玩的遊戲機，後來第二次世界大戰結束後，因為有大量的鋼鐵不知道怎麼處理，便拿去做小鋼珠，柏青哥的機台也越改越華麗，變成日本成年人的誤樂，至今日本仍需要年滿 18 歲才能進入遊玩。更詳細歷史可自行搜索。
柏青哥機台根據其主題不同，上面的機關按鈕也會不太一樣，但大致上的按鍵是相似的。
如上圖所示，右上角紅框處會標示該機台的機率，旁邊小一點的數字是確變模式的機率，確變模式我也不是很清楚，但主要看大數字的機率就可以了。常見的機率有 1/99、199/1、1/319。機率越高，開出來的獎就越小，反之機率越低，一旦開獎了，就會是較大的獎。這些機台的規格、機率都是必須要明文寫出來的，機台左手邊通常會有一個縫細放該機台的詳細規格。此外，機率最低也就是 1/319，這是日本政府避免大家賭太大而訂下的。
下面的紅框是觸控螢幕，會顯示該機台開獎的歷史紀錄，有些玩家會根據紀錄來決定要打哪一台。聽說高手都是看釘子的排列，而不是看這些紀錄的。
找到喜歡的機台後，必須先檢查該機台上沒有鋼珠，也沒有擺放任何東西 (手帕、飲料…等等)，若有各種東西在機台上，代表是其他客人先佔位置了。
如上圖所示，左上方的口可以放入紙鈔，放入不代表就要全打完，沒打完的可以退錢所以不用擔心。
如上圖所示，機台左側會有個小的觸控螢幕，機台有分 1 元跟 4 元的，代表你要花多少錢買一顆鋼珠。
而下面紅框處的 200 玉代表按一次玉貸便會吐 200 顆鋼珠給你。
機台右側通常會有幾個按鈕：返却、玉貸、光、音、十字鍵、還有一個沒寫字的大按鈕。
 返却：當你不打時，若還有錢或是鋼珠，按下這個按鈕，便會吐一張 IC 卡給你。 玉貸：按下這個按鈕便會將你剛剛投入的錢換成鋼珠，1 元的大多是一次換 200 元，也就是 200 顆鋼子；4 元的大多是一次換 1000 元，也就是 250 顆珠子。 光：調整機台的亮度 音：調整機台的音量 十字鍵：有些機台會讓你選歌曲或其他東西，便是用這個選。若機台上沒有光、音的按鈕，則是用十字鍵來調整。 大按鈕：這個按鈕是讓你把第一層鋼珠掉到第二層用的，不一定會是紅色的。  按下玉貸後，珠子就會跑出來了，輕輕轉動右下方的圓形把手，就會把珠子打出去，轉越多就打越遠。一開始要往左邊打，所以先輕輕轉就好。
如上二圖所示，每台機台中間下面都會有一個小洞，一開始目標就是要打進這個洞。要記得珠子一開始要往左邊打，從左邊掉下來才有機會進這個小洞。
珠子一旦進這個洞，就等於獲得一次抽獎機會，中間螢幕就會開始有動畫演示抽獎的過程。
中獎可以保留的次數是有上限的，也就是說如果你一下子進太多珠子，而機台動畫還在跑，這時候再進洞的珠子就沒用了。
如上圖，機台螢幕都會有一個類似這樣顯示你目前還有幾次抽獎機會，但不同主題的會不太一樣，有些不是很明顯。可以看的出來，上圖最多就只能保留五次抽獎機會，所以我通常會在有四次抽獎機會時就先不打珠子了，讓動畫跑一下把獎抽掉。
如果抽獎抽到三個一樣的數字，就是中獎進確變模式了 (平常有些數字也是會有獎項，但都不大，就是吐給你十幾二十顆之類的)。中獎時，有些機台會要你選關卡之類的，但無所謂，就隨便選吧，機台通常也會提示你要按什麼按鈕來選擇。
確變模式會進入另一種場景，這時候抽獎的機率就會提高，但是是有次數限制的。通常會在畫面的右手邊告訴你剩幾次，而一樣是有抽獎保留次數上限的。確變模式會很常讓你瞇牌，也常常會需要按機台上其他的按鈕。
如上圖，峰不二子機台的是一把手槍，可以往後拉且扣板機。
在這種模式又中獎的話，就真的中大獎了。這時候畫面會要你往右打 (右打ち)，這時候不用想，直接把圓形把手轉到底，瘋狂往右邊打就對了。
這時候機台右下角的會有一個大洞會開開關關的，目標就是打進這裡。也可以算準洞會開關的時間斷斷續續的打珠子不要浪費，但有點難。
結算完後，會告訴你這次贏了多少，而又回去原本的確變模式，而且次數又會補滿，於是又可以進行高機率抽獎，再中獎就再往右打，一直連莊循迴下去。
上圖是我中獎完的結算畫面。
柏青哥機台有分兩種，一種是傳統的，當珠子越來越多時，就需要叫工作人員給你盒子，讓你把珠子放進盒子擺到身後的地上。另一種是可以直接把珠子回存回去機台，就不需要一直拿盒子裝珠子了。
通常機台會有三層給珠子流動，第一層就是按下「玉貸」後，珠子掉出來的地方。
如上圖，是機台的第一層。上面有提到機台右邊會有一個沒有寫字的大按鈕，按著就可以讓珠子掉到第二層。
如上圖，是機台的第二層，若中大獎時，機台偵測到第一層滿了，就會直接把珠子吐到第二層。第二層通常會有個按鈕，如上圖紅框處，按下去後第二層就會開個洞，讓珠子掉到第三層，但不同主題的機台會長得很不一樣，有些很難辨認。
如上圖，回存到機台的珠子會顯示在左邊的小螢幕上 (持ち玉)。若第一次珠子打光了，可以按下左邊小螢幕下方的払出，就會吐珠子到第一層繼續打了。如果也沒有任何珠子，在機台裡，就只能再按「玉貸」花錢買珠子了。
若不想打了，也沒有珠子，也沒有剩餘的錢 (左邊小螢幕會寫著「入金殘高」，就是剩餘還在機台的錢)，那拍拍屁股直接走人就可以了 (記得等抽獎動畫跑完)。 <a class="read-more" href="https://chihkaiyu.github.io/post/introduction-to-pachinko/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/life/">#life</a>,
            
        
        <time class="post-date" datetime="2019-12-27T00:53:00&#43;08:00">
            27 Dec 2019
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/why-quick-sort-is-faster-than-heap-sort/">Why Quick Sort Is Faster than Heap Sort?</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Why Quick Sort? I was reviewing sorting algorithm for my interview. The question just popped up in my mind when I was peeking the cheat sheet.
[1]
You can see the best, average and worst time complexity of heap sort are all O(n logn) but it&rsquo;s O(n^2) for worst of quick sort.
Then why do we always use quick sort? Since quick sort can&rsquo;t beat heap sort in any cases, not even in space complexity. <a class="read-more" href="https://chihkaiyu.github.io/post/why-quick-sort-is-faster-than-heap-sort/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/algorithm/">#algorithm</a>,
            
        
        <time class="post-date" datetime="2019-10-02T01:10:00&#43;08:00">
            2 Oct 2019
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/golang-memory-management/">Golang Memory Management (based on 1.12.5)</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Golang Memory Management (based on 1.12.5) 此文是我在看過許多 Golang 記憶體管理的文章後，再搭配 souce code 所整理出來的。有點像是利用 souce code 來驗證我是否理解網路上所搜尋到的文章。
Golang 基於 TCMalloc (Thread-Caching Malloc) 加以修改，改為適合自己的 allocator。
TCMalloc 有幾項特點：
 盡可能先分配一大塊記憶體，以降低分配及釋放的 overhead 將這塊記憶體切成各種大小的 span，以降低 memory fragmentation 分配特別小的物件時優化，以提升記憶體使用率 Thread 裡有 cache，使用時可以不必 lock 以提升效率  Terminology Golang memory management 裡有許多角色，此段落先簡單介紹各角色功用，下段落會詳細各角色的結構及彼此之間的關係。
下圖為大致架構圖，可一邊閱讀一邊參閱：
mspan mspan 是 Golang 記憶體管理最小單位，由數頁 page 所組成，每一個 mspan 都會對應到一個 span class，用來決定該如何切割該 mspan 裡的 page。其 mspan 是 double-linked list。
page 經過切割後變為 object，此 object 才是真正分配記憶體的最小單位。
mcache 每個 P (Golang scheduler 的 logic processor)，會綁定一個 mcache，由於同一時間只會有一個 G (goroutine) 在 P 上跑，所以在存取時並不需要 lock。 <a class="read-more" href="https://chihkaiyu.github.io/post/golang-memory-management/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/golang/">#golang</a>,
            
        
        <time class="post-date" datetime="2019-07-02T00:03:00&#43;08:00">
            2 Jul 2019
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/chapter-vi-big-o/">Chapter VI - Big O</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Chapter VI - Big O Big O, Big Theta, and Big Omega 學術上使用 big O, big theta, big omega 來描述執行速度。然而工程上 (或是面試)，人們常會將 big theta 及 big O 混在一起。工程上的 big O 即是學術上的 big theta。
例如印出一個 array，在學術上說 O(N^2) 是正確的，但工程上我們會說這是 O(N)。
本書所有例子都會使用工程上的 big O。
O (big O) 學術上，big O 用來描述時間的 upper bound。例如印出一個 array 的值，可以說是 O(N)，但也可以說是 O(N^2)、O(N^3)。有點類似小於等於的概念。
Ω (big omega) 學術上，big omega 等價於 lower bound。例如印出一個 array 的值，可以說是 Ω(N)，也可以說是 Ω(log N) 或 Ω(1)。即是：不會比他 (N) 還更快。 <a class="read-more" href="https://chihkaiyu.github.io/post/chapter-vi-big-o/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/digest/">#digest</a>,
            
        
        <time class="post-date" datetime="2019-03-07T00:24:00&#43;08:00">
            7 Mar 2019
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/prometheus-survey/">Prometheus Survey</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Prometheus Survey Architecture Prometheus server 負責蒐集及儲存各 target 的 metrics，也會檢查 alert 規則，觸發後會發 alert 給 alertmanager。
Target 要被監控的目標，會以網頁方式將 metrics 以固定格式呈現給 prometheus server 抓取。
Pushgateway: 若有一些 target 不適合以抓取的方式獲得 metrics，例如存活時間很短的 job，prometheus server 還來不及抓就關閉了，則可以將 metrics 推送到 pushgateway，再讓 prometheus server 到 pushgateway 抓取 metrics。
Alertmanager: prometheus server 會檢查 alert 規則，將觸發的 alert 送到 alertmanager，而 alertmanager 會將 alert 整理後，確定可以發出才會將 alert 送往設定的 receiver。
Concepts Data Model  每一條 time series 由 metric name 及一組 labels 來辨別。 Metric name 必須符合此 regular expression: [a-zA-Z_:][a-zA-Z0-9_:]-。 Labels 使 Prometheus 可以有多維度的資料，對任何 label 值變動，都會產生一條新的 time series。 Labels 必須符合此 regular expression: [a-zA-Z_][a-zA-Z0-9_]-。 開頭是 __ 的 label 是預留給內部使用的。 Label 值可以使用任何 unicode 字元。 每一個採樣點是：  一個 float64 值 millisecond 等級的 timestamp  Metric name 及 labels 用法  &lt;metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, . <a class="read-more" href="https://chihkaiyu.github.io/post/prometheus-survey/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/sre/">#sre</a>,
            
                <a href="https://chihkaiyu.github.io/tags/digest/">#digest</a>,
            
        
        <time class="post-date" datetime="2019-01-15T22:16:00&#43;08:00">
            15 Jan 2019
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/clean-code-chapter-6/">Clean Code Digest - Chapter 6 物件及資料結構</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Chapter 6 物件及資料結構 TL; DR 我認為此章節所想表達的有下列事項： - 抽象化：資料需要抽象化隱藏其實作過程。在封裝起來後要依然能操作資料的本質。 - 互補：以資料結構為本位的程式容易增加新函式，但不易增加新的資料結構；以物件為本位的程式容易增加新類別，但不易增加新函式。
資料抽象化  類別提供了一個抽象介面，讓使用者在不需要知道實現過程的狀態下，還能夠操縱資料的本質 嚴謹一點的最好作法是，想辦法找到最能詮釋「資料抽象概念」的方式。 最糟糕的作法，則是天真快樂地加上讀取函式及設定函式而已。
 作者以座標點及交通工具剩餘油量作為例子： 座標點：
// 具體的座標點 type Point struct { X float64 Y float64 } // 抽象的座標點 type Point interface { getX() float64 getY() float64 setCartesian(float64, float64) getR() float64 getTheta() float64 setPolar(float64, float64) }  在抽象座標點裡，你無法分辨這個實現過程是平面座標還是極座標。這樣的界面除了清楚的表示這是一種資料結構外，還限制了存取的手段。 而在具體座標點裡，可以很清楚的知道這是直角座標，而且必須單獨操作各軸座標。
剩餘油量：
// 具體化的剩餘油量 type FuelTankCapacityInGallons interface { getGallonsOfGasoline() float64 } // 抽象化的剩餘油量 type Vehicle interface { getPercentFuelRemaining() float64 }  上述例子裡，具體化的剩餘油量很明顯看得出是直接存取某個變數，而抽象化的會回傳剩餘比例，我們並不知道實際內部資料型態如何。 <a class="read-more" href="https://chihkaiyu.github.io/post/clean-code-chapter-6/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/digest/">#digest</a>,
            
        
        <time class="post-date" datetime="2018-10-19T01:15:38&#43;08:00">
            19 Oct 2018
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/clean-code-chapter-5/">Clean Code Digest - Chapter 5 編排</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Chapter 5 編排 TL; DR 我認為此章節所想表達的有下列事項： - 編排的目的：作者認為編排會影響可讀性，而可讀性會不斷對日後的改變產生影響。甚至整本書其實都是在討論這件事 - 垂直：程式碼由上而下閱讀，應該像報紙一樣，由概要、概念、細節逐一深入。而程式碼之間的垂直距離以宣告的地方、使用的地方、本質來決定 - 水平：水平的空白間隔用來區分事情，例如 = 前後加入空白使其更突出，或是用來強調運算子的優先權。另一個用途是縮排，縮排決定了視野，而視野讓程式設計師可以快速替程式區塊作分類
編排的目的  程式編排是很重要的。 程式碼的可讀性，將會對以後每個可能的改變，產生深遠的影響。
 這裡提編排是很重要，理由是會影響程式碼可讀性；程式碼可讀性很重要，理由如同前幾章提到的，可讀性會影響該程式碼是否易於修改。 有一派人會主張程式只要能正常運作就好，討論一堆枝微末節的小事根本是浪費時間。但我認為就是要讓程式正常運作，才需要討論這些小事，除非你認為程式碼隨便寫一寫就可以正常運作了。
垂直的編排  簡短的程式碼往往比大型的程式檔更容易讓人理解。
 作者分析了七個 Java 的 open source 專案的程式碼檔案長度，如下圖： 細線的上下兩端分別代表最長行數及最短行數，而方塊則是上下半個標準差，所以方塊的中間便是平均值。 作者想傳達的是，要建造一個大型系統，程式碼不必很長就可以辦到，不用動不動就上千行。
報紙的啟發  在原始檔的最上方，能夠提供高階的概念和演算法，在往下閱讀的時候，程式的細節會慢慢地呈現，直到發現原始檔中最低階的函式及細節為止。
 作者此處以報紙文章的書寫方式為例：報紙的頭條告訴你整篇報導在談論什麼。接著第一段描述整篇報導的概要，再來慢慢的詳述細節，最後你讀到所有日期、姓名、引言、主張等內容。 我認為的層次大約是：概要 -&gt; 概念 -&gt; 細節。在 chapter 3 函式裡有提到降層準則，我認為非常適合以這種模式去分層，同時每一個函式只做同一層次的事情。
概念間的垂直空白區隔  每一段程式碼都代表一個完整的思緒，應該用空白行來分隔這些思緒。
 在閱讀本書前，我自己 coding 時便常常做這件事，例如底下程式碼：
func main() { err := initConfig() if err != nil { log.Fatal(err) } err = initDatabaseConnection() if err ! <a class="read-more" href="https://chihkaiyu.github.io/post/clean-code-chapter-5/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/digest/">#digest</a>,
            
        
        <time class="post-date" datetime="2018-10-11T00:49:10&#43;08:00">
            11 Oct 2018
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/clean-code-chapter-4/">Clean Code Digest - Chapter 4 註解</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Chapter 4 註解 TL; DR 我認為此章節所想表達的有下列事項： - 最後一道防線：作者認為註解是最後手段，在寫下註解前，你應該好好的審視程式碼是否能改寫得更好，盡量讓程式碼本身就能表達出足夠的含義 - 好的註解：這些註解都不應該解釋程式碼怎麼運作，而是為什麼要這麼做，或是不這麼做的後果會是什麼 - 壞的註解：可以從 git 得到的資訊就不需要再寫註解了。規定一定要寫下某些註解是很愚蠢的。別使註解干擾或誤導他人。
Chapter 4 註解  「不要替糟糕的程式碼寫註解－－重寫它」－－Brian W. Kernighan and P.J. Plaugher 適當地使用註解是用來「彌補我們用程式碼表達意圖的失敗」。 一個註解存在越久，事實就越來越偏離當初的程式碼解釋。
 此段落其實在告訴你不要寫註解，作者主要有底下兩個理由： - 寫註解代表你的程式碼不足以表現意圖，你應該修改你的程式碼 - 程式碼總是一直被修改，於是註解與程式碼內容越差越遠，最後註解將會誤導你
註解無法彌補糟糕的程式碼  整潔具有表達力又極少使用註解的程式碼，遠優於雜亂複雜又滿是註解的程式碼。 與其花時間寫註解來解釋你所造成的混亂，不如花時間去整理那堆混亂的程式碼。
 用程式碼表達你的本意  在大部份情況下，你想要寫下的註解，都可以簡單地融入到建立的函式名稱當中。
 作者在這裡舉了一個例子：
// Check to see if the employee is eligible for full benefits if (employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65)  if employee.isEligibleForFullBenefits()  因為程式碼是唯一的真相，註解寫的再詳細清楚都有可能是背離事實的。如果能從程式碼表達出意圖，就再也不需要寫下註解來誤導人。
有益的註解  真正有益的註解，是你想辦法不寫它的註解。 <a class="read-more" href="https://chihkaiyu.github.io/post/clean-code-chapter-4/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/digest/">#digest</a>,
            
        
        <time class="post-date" datetime="2018-10-10T14:33:00&#43;08:00">
            10 Oct 2018
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/clean-code-chapter-3/">Clean Code Digest - Chapter 3 函式</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Chapter 3 函式 TL; DR 我認為此章節所想表達的有下列事項： - 簡短：整章其實都圍繞著「簡短」打轉，像是函式只做一件事，且是同一層抽象概念的事，一直到不要重複自己都是在想辦法盡量讓函式 (程式碼) 簡短。 - 故事：一份程式碼是在描述系統的故事，函式是動詞，類別是名詞，函式訴說著他對系統裡的東西做了什麼事。良好的命名及漂亮的結構最後整潔的結合在一起，便能順暢的說出系統的故事。
簡短！  關於函式的首要準則就是要簡短。第二項準則就是要比第一項更簡短。 每個函式都一清二楚，透露出本身的意圖。每個函式帶領著你至下個函式，這就是經式該有的簡短。
 這段直接破題告讓你函式就是要短，而且是毫無研究上的支持，完全是作者自己的經驗談。我們也知道看一個長度 50 行的函式與 500 行的函式在閱讀起來是截然不同的感受。我在拆函式的習慣是滿隨性的，我會將主要流程分為幾個步驟，將各個步驟都寫成一個函式。 這段另外提到了區塊 (blocks) 及縮排 (indenting)，他提到條件敘述應該只有一行，且那行便是函式呼叫。這不僅維持封閉式的簡短，若函式名稱取得好還能用來描述意圖。而這也意味著函式不應該大到包含巢狀結構，因此函式裡的縮排不應該大過一或兩層。但這件事我認為在 Python 裡非常難做到，尤其 Python 又是以縮排作為 blocks 的區別。
只做一件事情  函式應該做一件事情，它們應該把這件事做好，而且它們應該只做這件事。 如果函式只做了函式名稱下「同一層抽象概念」的幾個步驟，那這個函式就算是只作了一件事。 做一件事的函式沒有辦法被合理地分成不同的段落。
 這段最難拿捏的就是其中的「只做一件事」，該怎麼定義「一件事」？作者以底下程式碼為例：
func RenderPageWithSetupsAndTeardowns(pageData PageData, isSuite bool) string { if isTestPage(pageData) { includeSetupAndTeardownPages(pageData, isSuite) } return pageData.getHtml() }  這段程式碼只做一件事嗎？還是做了三件事？ 作者的判斷標準在於「同一層抽象概念」。作者給的定義則是：看你是否能夠從函式中提煉出另外一個新函式，但此新函式不能只是重新詮釋原函式的實作而已。 底下程式碼是我的 side project 的其中一個函式，很明顯的可以看到有三個段落，甚至我自己還寫了註解：
func updateAllUsers() error { // get users from db stmt, err := db. <a class="read-more" href="https://chihkaiyu.github.io/post/clean-code-chapter-3/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/digest/">#digest</a>,
            
        
        <time class="post-date" datetime="2018-09-27T23:18:56&#43;08:00">
            27 Sep 2018
        </time>
    </footer>
</article>

	
	   <article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://chihkaiyu.github.io/post/clean-code-chapter-2/">Clean Code Digest - Chapter 2 有意義的命名</a></h2>
    </header>
    <section class="post-excerpt">
        
            <p>Chapter 2 有意義的命名 TL; DR 我認為此章節所想表達的有下列事項： - 意圖：取一個好名稱便能得知此類別、物件、函式、變數的含義，或是它想要做什麼事、被做什麼事 - 一致性：永遠使用同一個字詞來表達相同的抽象概念，同樣語意使用不同字詞會使人誤會 - 區別性：與前一項相反，不相同的東西就讓他能輕易被分別出來 - 社交：使其他人輕鬆維護、開發同一份程式碼，包含面對面的討論
讓名稱代表意圖 - 使之名副其實  變數、函式或類別的名稱，要能解決大部份的問題。如果一個名稱還需要註解的輔助，那麼這個名稱就不具備展現意圖的能力。
 Naming is hard，對於母語不是英文的亞洲人來說，要選一個合適的詞彙並貼切你想表達的意圖就更難了。以往我會盡量避免使用過長的命名，但這本書似乎是鼓勵你這麼做，比起模糊不清，一眼就能看出意圖是更重要的事。 此書舉了一個例子 (我改寫為 Golang)：
func getThem() { list1 := []string for _, x := range list1 { if x[0] == 4 { list1 = append(list1, x) } } }  此段程式碼有許多你必須跳至該變數的宣告處或是賦值處，才能得知他的含義，這導致閱讀程式碼時必須一直中斷思考。作者給了一個改寫過的例子，假設現在要開發一款踩地雷遊戲：
func getFlaggedCells() [][]int { flaggedCells := [][]int for _, cell := gameBoard { if cell[STATUS_VALUE] == FLAGGED { flaggedCells = append(flaggedCells, cell) } } return flaggedCells }  上述程式碼將無意義的命名 (list1、x) 及無意義的常數 (x[0]、4) 都轉變成一看就能了解的命名，使閱讀者不需自己再將無意義的名稱 mapping 到實際含義。 <a class="read-more" href="https://chihkaiyu.github.io/post/clean-code-chapter-2/">&raquo;</a></p>
        
    </section>
    <footer class="post-meta">
        

        
            
            

            
            <img class="author-thumb" src="https://chihkaiyu.github.io/images/profile.png" alt="Author image" nopin="nopin" />
            
            
            
            Chih Kai Yu
                 
        

        on
            
                <a href="https://chihkaiyu.github.io/tags/digest/">#digest</a>,
            
        
        <time class="post-date" datetime="2018-09-19T22:51:00&#43;08:00">
            19 Sep 2018
        </time>
    </footer>
</article>

	

	<nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 2</span>
	
	    <a class="older-posts" href="https://chihkaiyu.github.io/post/page/2/">Older Posts &rarr;</a>
	
</nav>

</main>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">No Idiots Allowed Here</a> </section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://chihkaiyu.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://chihkaiyu.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://chihkaiyu.github.io/js/index.js"></script>
    
</body>
</html>
